<html>
<head>
<title>FCSys.Subregions.Species</title>
<meta name="keywords" content="fuel cell library, FCSys, fuel cell, PEM, proton exchange membrane, polymer exchange membrance, PEMFC, Modelica, Dymola, electrochemistry">
<meta name="date" content="2013-1-16">
<meta name="description" content="Models for single-species storage, transport, and exchange of material, linear momentum, and energy">
<link rel="stylesheet" type="text/css" charset="utf-8" media="all" href="stylesheets/ModelicaDoc.css">
<link rel="shortcut icon" href="../resources/documentation/favicon.ico">
<script type="text/javascript" src="javascripts/analytics.js"></script>
</head>
<body>
<div class="sidebar">
  <div class="sidebarwrapper">
  <a href="index.html"><p class="sidebar-title">FCSys</p></a>
  <p class="logo"><a href="index.html">
    <img src="images/icon.gif" class="logo" alt="Logo" width=150>
  </a></p>

  <h3>Table of Contents</h3>
    <ul>
    <li><a href="FCSys_UsersGuide.html">User's Guide</a></li>
    <li><a href="FCSys_BCs.html">BCs</a></li>
    <li><a href="FCSys_Sensors.html">Sensors</a></li>
    <li><a href="FCSys_Assemblies.html">Assemblies</a></li>
    <li><a href="FCSys_Regions.html">Regions</a></li>
    <li><a href="FCSys_Subregions.html">Subregions</a></li>
    <li><a href="FCSys_Connectors.html">Connectors</a></li>
    <li><a href="FCSys_Characteristics.html">Characteristics</a></li>
    <li><a href="FCSys_Units.html">Units</a></li>
    <li><a href="FCSys_Quantities.html">Quantities</a></li>
    <li><a href="FCSys_BaseClasses.html">BaseClasses</a></li>
    </ul>

  <h3>Download</h3>
    <ul>
      <li>Latest: <a href="release/FCSys-2.0.zip" rel="nofollow">FCSys-2.0.zip</a> (**Please check back soon or contact kdavies4 at gmail.com.)</li>
    </ul>
  </div>
</div>

<div class="document">
  <div class="documentwrapper">
    <div class="bodywrapper">
      <div class="body">

<h2><a name="FCSys.Subregions.Species"></a><a href="FCSys_Subregions.html#FCSys.Subregions">FCSys.Subregions</a>.Species</h2>
<b>Models for single-species storage, transport, and exchange of material, linear momentum, and energy</b>
<p>
<p><h3>Information</h3></p>
Extends from <a href="http://build.openmodelica.org/Documentation/Modelica.Icons.Package.html#Modelica.Icons.Package">Modelica.Icons.Package</a> (Icon for standard packages).
<p><h3>Package Content</h3><p>
<table border=1 cellspacing=0 cellpadding=2 >
<tr><th>Name</th><th>Description</th></tr>
<tr><td><img src="images/FCSys.Subregions.Species.CS.png" alt="FCSys.Subregions.Species.C" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species_C.html#FCSys.Subregions.Species.C">C</a>
</td><td>C</td></tr>
<tr><td><img src="images/FCSys.Subregions.Species.CS.png" alt="FCSys.Subregions.Species.C19HF37O5S" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species_C19HF37O5S.html#FCSys.Subregions.Species.C19HF37O5S">C19HF37O5S</a>
</td><td>C<sub>19</sub>HF<sub>37</sub>O<sub>5</sub>S</td></tr>
<tr><td><img src="images/FCSys.Subregions.Species.CS.png" alt="FCSys.Subregions.Species.'e-'" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species_'e-'.html#FCSys.Subregions.Species.'e-'">'e-'</a>
</td><td>e<sup>-</sup></td></tr>
<tr><td><img src="images/FCSys.Subregions.Species.CS.png" alt="FCSys.Subregions.Species.'H+'" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species_'H+'.html#FCSys.Subregions.Species.'H+'">'H+'</a>
</td><td>H<sup>+</sup></td></tr>
<tr><td><img src="images/FCSys.Subregions.Species.CS.png" alt="FCSys.Subregions.Species.H2" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species_H2.html#FCSys.Subregions.Species.H2">H2</a>
</td><td>H<sub>2</sub></td></tr>
<tr><td><img src="images/FCSys.Subregions.Species.CS.png" alt="FCSys.Subregions.Species.H2O" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species_H2O.html#FCSys.Subregions.Species.H2O">H2O</a>
</td><td>H<sub>2</sub>O</td></tr>
<tr><td><img src="images/FCSys.Subregions.Species.CS.png" alt="FCSys.Subregions.Species.N2" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species_N2.html#FCSys.Subregions.Species.N2">N2</a>
</td><td>N<sub>2</sub></td></tr>
<tr><td><img src="images/FCSys.Subregions.Species.CS.png" alt="FCSys.Subregions.Species.O2" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species_O2.html#FCSys.Subregions.Species.O2">O2</a>
</td><td>O<sub>2</sub></td></tr>
<tr><td><img src="images/FCSys.Subregions.Species.SpeciesSolidS.png" alt="FCSys.Subregions.Species.SpeciesSolid" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.SpeciesSolid">SpeciesSolid</a>
</td><td>Solid species (inert and stagnant)</td></tr>
<tr><td><img src="images/FCSys.Subregions.Species.SpeciesSolidS.png" alt="FCSys.Subregions.Species.SpeciesIncompressible" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.SpeciesIncompressible">SpeciesIncompressible</a>
</td><td>Incompressible species</td></tr>
<tr><td><img src="images/FCSys.Subregions.Species.SpeciesSolidS.png" alt="FCSys.Subregions.Species.Species" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.Species">Species</a>
</td><td>Model for single-species exchange, transport, and storage of material, linear momentum, and energy</td></tr>
<tr><td><img src="images/FCSys.Subregions.Species.BaseClassesS.png" alt="FCSys.Subregions.Species.BaseClasses" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses">BaseClasses</a>
</td><td>Base classes (not for direct use)</td></tr>
</table>
<hr>

<h2><img src="images/FCSys.Subregions.Species.SpeciesSolidI.png" alt="FCSys.Subregions.Species.SpeciesSolid" align=RIGHT border=1 width=80  height=80 >
<a name="FCSys.Subregions.Species.SpeciesSolid"></a><a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species">FCSys.Subregions.Species</a>.SpeciesSolid</h2>
<b>Solid species (inert and stagnant)</b><p>
<img src="images/FCSys.Subregions.Species.SpeciesSolidD.png" alt="FCSys.Subregions.Species.SpeciesSolid">
<p><h3>Information</h3></p>
<p>Assumptions:<ol>
  <li>Zero velocity</li>
  <li>No material exchange or transport</li</ol>
  </p>

  <p>For more information, see the <a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.Species">Species</a> model.</p><p>
Extends from <a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.SpeciesIncompressible">SpeciesIncompressible</a> (Incompressible species).
<p><h3>Parameters</h3><p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Type</th><th>Name</th><th>Default</th><th>Description</th></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Geometry</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Length">Length</a></td><td>Lstar</td><td>&nbsp;</td><td>Characteristic length for exchange (<i>L</i><sup>&#9733;</sup>) [l]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">NumberAbsolute</a></td><td>k[Axis]</td><td>{1,1,1}</td><td>Area fill factor for transport (<b>k</b>) [1]</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Material properties</td></tr>
<tr><TD colspan="2">replaceable package Data</td><td><a href="FCSys_Characteristics_BaseClasses_Characteristic.html#FCSys.Characteristics.BaseClasses.Characteristic">Characteristic</a></td><td>Characteristic data</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Fusivity">Fusivity</a></td><td>Xi</td><td>Modelica.Constants.inf</td><td>Fusivity (&Xi;) [T/l2]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Fluidity">Fluidity</a></td><td>F</td><td>0</td><td>Fluidity [l.T/m]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.ResistivityThermal">ResistivityThermal</a></td><td>R</td><td>Data.R(T, 1/rho)</td><td>Thermal resistivity</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=4><b>Assumptions</b></td></tr>
<tr><td>Boolean</td><td>overrideEOS</td><td>false</td><td>Override the equation of state with the value of &rho;<sub>IC</sub></td></tr>
<tr><td>Boolean</td><td>inclLin[Axis]</td><td>{true,false,false}</td><td>true, if each component of linear momentum is included (<i>Do not adjust here.</i>)</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Prescribed states (via initialization parameters)</td></tr>
<tr><td>Boolean</td><td>setPartNum</td><td>true</td><td>Particle number</td></tr>
<tr><td>Boolean</td><td>setVelX</td><td>true</td><td>X-axis component of velocity</td></tr>
<tr><td>Boolean</td><td>setVelY</td><td>true</td><td>Y-axis component of velocity</td></tr>
<tr><td>Boolean</td><td>setVelZ</td><td>true</td><td>Z-axis component of velocity</td></tr>
<tr><td>Boolean</td><td>setTemp</td><td>false</td><td>Temperature</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=4><b>Initialization</b></td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Scalar properties</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethScalar">InitMethScalar</a></td><td>initMethPartNum</td><td>InitMethScalar.Volume</td><td>Method of initializing the particle number</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethScalar">InitMethScalar</a></td><td>initMethTemp</td><td>InitMethScalar.Temperature</td><td>Method of initializing the temperature</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Amount">Amount</a></td><td>N_IC</td><td>&nbsp;</td><td>Initial particle number (<i>N</i><sub>IC</sub>) [N]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Current">Current</a></td><td>derN_IC</td><td>0</td><td>Initial rate of particle number ((&part;<i>N</i>/&part;<i>t</i>)<sub>IC</sub>) [N/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.AmountVolumic">AmountVolumic</a></td><td>rho_IC</td><td>&nbsp;</td><td>Initial volumic amount (&rho;<sub>IC</sub>) [N/l3]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.AmountVolumicRate">AmountVolumicRate</a></td><td>derrho_IC</td><td>0</td><td>Initial rate of volumic amount ((&part;&rho;/&part;<i>t</i>)<sub>IC</sub>) [N/(l3.T)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Volume">Volume</a></td><td>V_IC</td><td>&nbsp;</td><td>Initial volume (<i>V</i><sub>IC</sub>) [l3]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.VolumeRate">VolumeRate</a></td><td>derV_IC</td><td>0</td><td>Initial rate of volume ((&part;<i>V</i>/&part;<i>t</i>)<sub>IC</sub>) [l3/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PressureAbsolute">PressureAbsolute</a></td><td>p_IC</td><td>&nbsp;</td><td>Initial pressure (<i>p</i><sub>IC</sub>) [m/(l.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PressureRate">PressureRate</a></td><td>derp_IC</td><td>0</td><td>Initial rate of pressure ((&part;<i>p</i>/&part;<i>t</i>)<sub>IC</sub>) [m/(l.T3)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureAbsolute">TemperatureAbsolute</a></td><td>T_IC</td><td>&nbsp;</td><td>Initial temperature (<i>T</i><sub>IC</sub>)</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureRate">TemperatureRate</a></td><td>derT_IC</td><td>0</td><td>Initial rate of temperature (&part;<i>T</i>/&part;<i>t</i>)<sub>IC</sub>)</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">NumberAbsolute</a></td><td>s_IC</td><td>&nbsp;</td><td>Initial specific entropy (<i>s</i><sub>IC</sub>) [1]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.NumberRate">NumberRate</a></td><td>ders_IC</td><td>0</td><td>Initial rate of specific entropy ((&part;<i>s</i>/&part;<i>t</i>)<sub>IC</sub>) [1/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Potential</a></td><td>h_IC</td><td>&nbsp;</td><td>Initial specific enthalpy (<i>h</i><sub>IC</sub>) [l2.m/(N.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PotentialRate">PotentialRate</a></td><td>derh_IC</td><td>0</td><td>Initial rate of specific enthalpy ((&part;<i>h</i>/&part;<i>t</i>)<sub>IC</sub>) [l2.m/(N.T3)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Potential</a></td><td>mu_IC</td><td>&nbsp;</td><td>Initial electrochemical potential (&mu;<sub>IC</sub>) [l2.m/(N.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PotentialRate">PotentialRate</a></td><td>dermu_IC</td><td>0</td><td>Initial rate of electrochemical potential ((&part;&mu;/&part;<i>t</i>)<sub>IC</sub>) [l2.m/(N.T3)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Current">Current</a></td><td>Ndot_IC</td><td>0</td><td>Initial reaction rate (<i>N&#775;</i><sub>IC</sub>) [N/T]</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Velocity</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">InitMethVelocity</a></td><td>initMethX</td><td>InitMethVelocity.Velocity</td><td>Method of initializing the x-axis component</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">InitMethVelocity</a></td><td>initMethY</td><td>InitMethVelocity.Velocity</td><td>Method of initializing the y-axis component</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">InitMethVelocity</a></td><td>initMethZ</td><td>InitMethVelocity.Velocity</td><td>Method of initializing the z-axis component</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Velocity">Velocity</a></td><td>phi_IC[Axis]</td><td>zeros(3)</td><td>Initial velocity (<b>&phi;</b><sub>IC</sub>) [l/T]</td></tr>
</table>
<p><h3>Connectors</h3><p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Type</th><th>Name</th><th>Description</th></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.ChemicalOutput">ChemicalOutput</a></td><td>chemical</td><td>Connector to exchange material while advecting linear momentum and energy</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Inert">Inert</a></td><td>common</td><td>Connector for direct mechanical and thermal coupling of multiple species</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.InertDalton">InertDalton</a></td><td>inert</td><td>Connector to exchange linear momentum and heat by diffusion, with additivity of pressure</td></tr>
</table>
<p><h3>Modelica definition</h3>
<pre>
<font color="blue">model</font> SpeciesSolid <font color="darkgreen">&quot;Solid species (inert and stagnant)&quot;</font>
  <font color="blue">extends </font><a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.SpeciesIncompressible">SpeciesIncompressible</a>(
    <font color="blue">final </font>Xi=Modelica.Constants.inf,
    <font color="blue">final </font>F=0,
    <font color="blue">final </font>upstreamX,
    <font color="blue">final </font>upstreamY,
    <font color="blue">final </font>upstreamZ,
    <font color="blue">final </font>setPartNum=true,
    <font color="blue">final </font>setVelX=true,
    <font color="blue">final </font>setVelY=true,
    <font color="blue">final </font>setVelZ=true,
    <font color="blue">final </font>initMethX=InitMethVelocity.Velocity,
    <font color="blue">final </font>initMethY=InitMethVelocity.Velocity,
    <font color="blue">final </font>initMethZ=InitMethVelocity.Velocity,
    <font color="blue">final </font>Ndot_IC=0,
    <font color="blue">final </font>phi_IC=<font color="red">zeros</font>(3),
    <font color="blue">final </font>derphi_IC,
    <font color="blue">final </font>I_IC,
    <font color="blue">final </font>derI_IC,
    xNegative(
      thermoOpt=ThermoOpt.ClosedDiabatic,
      <font color="blue">final </font>inviscidY=true,
      <font color="blue">final </font>inviscidZ=true),
    xPositive(
      thermoOpt=ThermoOpt.ClosedDiabatic,
      <font color="blue">final </font>inviscidY=true,
      <font color="blue">final </font>inviscidZ=true),
    yNegative(
      thermoOpt=ThermoOpt.ClosedDiabatic,
      <font color="blue">final </font>inviscidZ=true,
      <font color="blue">final </font>inviscidX=true),
    yPositive(
      thermoOpt=ThermoOpt.ClosedDiabatic,
      <font color="blue">final </font>inviscidZ=true,
      <font color="blue">final </font>inviscidX=true),
    zNegative(
      thermoOpt=ThermoOpt.ClosedDiabatic,
      <font color="blue">final </font>inviscidX=true,
      <font color="blue">final </font>inviscidY=true),
    zPositive(
      thermoOpt=ThermoOpt.ClosedDiabatic,
      <font color="blue">final </font>inviscidX=true,
      <font color="blue">final </font>inviscidY=true));

  <font color="darkgreen">// Note:  upstreamX, upstreamY, and upstreamZ don&#39;t matter since bulk</font>
  <font color="darkgreen">// current is zero.</font>

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>SpeciesSolid;
</pre>
<hr>

<h2><img src="images/FCSys.Subregions.Species.SpeciesSolidI.png" alt="FCSys.Subregions.Species.SpeciesIncompressible" align=RIGHT border=1 width=80  height=80 >
<a name="FCSys.Subregions.Species.SpeciesIncompressible"></a><a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species">FCSys.Subregions.Species</a>.SpeciesIncompressible</h2>
<b>Incompressible species</b><p>
<img src="images/FCSys.Subregions.Species.SpeciesSolidD.png" alt="FCSys.Subregions.Species.SpeciesIncompressible">
<p><h3>Information</h3></p>

  <p>For more information, see the <a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.Species">Species</a> model.</p><p>
Extends from <a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.Species">Species</a> (Model for single-species exchange, transport, and storage of material, linear momentum, and energy).
<p><h3>Parameters</h3><p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Type</th><th>Name</th><th>Default</th><th>Description</th></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Geometry</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Length">Length</a></td><td>Lstar</td><td>&nbsp;</td><td>Characteristic length for exchange (<i>L</i><sup>&#9733;</sup>) [l]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">NumberAbsolute</a></td><td>k[Axis]</td><td>{1,1,1}</td><td>Area fill factor for transport (<b>k</b>) [1]</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Material properties</td></tr>
<tr><TD colspan="2">replaceable package Data</td><td><a href="FCSys_Characteristics_BaseClasses_Characteristic.html#FCSys.Characteristics.BaseClasses.Characteristic">Characteristic</a></td><td>Characteristic data</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Fusivity">Fusivity</a></td><td>Xi</td><td>Data.Xi(T, 1/rho)</td><td>Fusivity (&Xi;) [T/l2]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Fluidity">Fluidity</a></td><td>F</td><td>Data.F(T, 1/rho)</td><td>Fluidity [l.T/m]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.ResistivityThermal">ResistivityThermal</a></td><td>R</td><td>Data.R(T, 1/rho)</td><td>Thermal resistivity</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=4><b>Assumptions</b></td></tr>
<tr><td>Boolean</td><td>overrideEOS</td><td>false</td><td>Override the equation of state with the value of &rho;<sub>IC</sub></td></tr>
<tr><td>Boolean</td><td>inclLin[Axis]</td><td>{true,false,false}</td><td>true, if each component of linear momentum is included (<i>Do not adjust here.</i>)</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Axes with upstream discretization</td></tr>
<tr><td>Boolean</td><td>upstreamX</td><td>true</td><td>X</td></tr>
<tr><td>Boolean</td><td>upstreamY</td><td>true</td><td>Y</td></tr>
<tr><td>Boolean</td><td>upstreamZ</td><td>true</td><td>Z</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Prescribed states (via initialization parameters)</td></tr>
<tr><td>Boolean</td><td>setPartNum</td><td>false</td><td>Particle number</td></tr>
<tr><td>Boolean</td><td>setVelX</td><td>false</td><td>X-axis component of velocity</td></tr>
<tr><td>Boolean</td><td>setVelY</td><td>false</td><td>Y-axis component of velocity</td></tr>
<tr><td>Boolean</td><td>setVelZ</td><td>false</td><td>Z-axis component of velocity</td></tr>
<tr><td>Boolean</td><td>setTemp</td><td>false</td><td>Temperature</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Characteristics of the faces (click to edit)</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.FaceX">FaceX</a></td><td>xNegative</td><td>&nbsp;</td><td>Negative face along the x axis</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.FaceX">FaceX</a></td><td>xPositive</td><td>&nbsp;</td><td>Positive face along the x axis</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.FaceY">FaceY</a></td><td>yNegative</td><td>&nbsp;</td><td>Negative face along the y axis</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.FaceY">FaceY</a></td><td>yPositive</td><td>&nbsp;</td><td>Positive face along the y axis</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.FaceZ">FaceZ</a></td><td>zNegative</td><td>&nbsp;</td><td>Negative face along the z axis</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.FaceZ">FaceZ</a></td><td>zPositive</td><td>&nbsp;</td><td>Positive face along the z axis</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=4><b>Initialization</b></td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Scalar properties</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethScalar">InitMethScalar</a></td><td>initMethPartNum</td><td>InitMethScalar.Volume</td><td>Method of initializing the particle number</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethScalar">InitMethScalar</a></td><td>initMethTemp</td><td>InitMethScalar.Temperature</td><td>Method of initializing the temperature</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Amount">Amount</a></td><td>N_IC</td><td>&nbsp;</td><td>Initial particle number (<i>N</i><sub>IC</sub>) [N]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Current">Current</a></td><td>derN_IC</td><td>0</td><td>Initial rate of particle number ((&part;<i>N</i>/&part;<i>t</i>)<sub>IC</sub>) [N/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.AmountVolumic">AmountVolumic</a></td><td>rho_IC</td><td>&nbsp;</td><td>Initial volumic amount (&rho;<sub>IC</sub>) [N/l3]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.AmountVolumicRate">AmountVolumicRate</a></td><td>derrho_IC</td><td>0</td><td>Initial rate of volumic amount ((&part;&rho;/&part;<i>t</i>)<sub>IC</sub>) [N/(l3.T)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Volume">Volume</a></td><td>V_IC</td><td>&nbsp;</td><td>Initial volume (<i>V</i><sub>IC</sub>) [l3]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.VolumeRate">VolumeRate</a></td><td>derV_IC</td><td>0</td><td>Initial rate of volume ((&part;<i>V</i>/&part;<i>t</i>)<sub>IC</sub>) [l3/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PressureAbsolute">PressureAbsolute</a></td><td>p_IC</td><td>&nbsp;</td><td>Initial pressure (<i>p</i><sub>IC</sub>) [m/(l.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PressureRate">PressureRate</a></td><td>derp_IC</td><td>0</td><td>Initial rate of pressure ((&part;<i>p</i>/&part;<i>t</i>)<sub>IC</sub>) [m/(l.T3)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureAbsolute">TemperatureAbsolute</a></td><td>T_IC</td><td>&nbsp;</td><td>Initial temperature (<i>T</i><sub>IC</sub>)</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureRate">TemperatureRate</a></td><td>derT_IC</td><td>0</td><td>Initial rate of temperature (&part;<i>T</i>/&part;<i>t</i>)<sub>IC</sub>)</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">NumberAbsolute</a></td><td>s_IC</td><td>&nbsp;</td><td>Initial specific entropy (<i>s</i><sub>IC</sub>) [1]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.NumberRate">NumberRate</a></td><td>ders_IC</td><td>0</td><td>Initial rate of specific entropy ((&part;<i>s</i>/&part;<i>t</i>)<sub>IC</sub>) [1/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Potential</a></td><td>h_IC</td><td>&nbsp;</td><td>Initial specific enthalpy (<i>h</i><sub>IC</sub>) [l2.m/(N.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PotentialRate">PotentialRate</a></td><td>derh_IC</td><td>0</td><td>Initial rate of specific enthalpy ((&part;<i>h</i>/&part;<i>t</i>)<sub>IC</sub>) [l2.m/(N.T3)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Potential</a></td><td>mu_IC</td><td>&nbsp;</td><td>Initial electrochemical potential (&mu;<sub>IC</sub>) [l2.m/(N.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PotentialRate">PotentialRate</a></td><td>dermu_IC</td><td>0</td><td>Initial rate of electrochemical potential ((&part;&mu;/&part;<i>t</i>)<sub>IC</sub>) [l2.m/(N.T3)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Current">Current</a></td><td>Ndot_IC</td><td>0</td><td>Initial reaction rate (<i>N&#775;</i><sub>IC</sub>) [N/T]</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Velocity</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">InitMethVelocity</a></td><td>initMethX</td><td>InitMethVelocity.Velocity</td><td>Method of initializing the x-axis component</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">InitMethVelocity</a></td><td>initMethY</td><td>InitMethVelocity.Velocity</td><td>Method of initializing the y-axis component</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">InitMethVelocity</a></td><td>initMethZ</td><td>InitMethVelocity.Velocity</td><td>Method of initializing the z-axis component</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Velocity">Velocity</a></td><td>phi_IC[Axis]</td><td>{0,0,0}</td><td>Initial velocity (<b>&phi;</b><sub>IC</sub>) [l/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Acceleration">Acceleration</a></td><td>derphi_IC[Axis]</td><td>{0,0,0}</td><td>Initial acceleration ((&part;<b>&phi;</b>/&part;<i>t</i>)<sub>IC</sub>) [l/T2]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Current">Current</a></td><td>I_IC[Axis]</td><td>{0,0,0}</td><td>Initial current (<i><b>I</b></i><sub>IC</sub>) [N/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.CurrentRate">CurrentRate</a></td><td>derI_IC[Axis]</td><td>{0,0,0}</td><td>Initial rate of current ((&part;<i><b>I</b></i>/&part;<i>t</i>)<sub>IC</sub>) [N/T2]</td></tr>
</table>
<p><h3>Connectors</h3><p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Type</th><th>Name</th><th>Description</th></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.ChemicalOutput">ChemicalOutput</a></td><td>chemical</td><td>Connector to exchange material while advecting linear momentum and energy</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Inert">Inert</a></td><td>common</td><td>Connector for direct mechanical and thermal coupling of multiple species</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.InertDalton">InertDalton</a></td><td>inert</td><td>Connector to exchange linear momentum and heat by diffusion, with additivity of pressure</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=3><b>Assumptions</b></td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=3>Characteristics of the faces (click to edit)</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.FaceX">FaceX</a></td><td>xNegative</td><td>Negative face along the x axis</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.FaceX">FaceX</a></td><td>xPositive</td><td>Positive face along the x axis</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.FaceY">FaceY</a></td><td>yNegative</td><td>Negative face along the y axis</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.FaceY">FaceY</a></td><td>yPositive</td><td>Positive face along the y axis</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.FaceZ">FaceZ</a></td><td>zNegative</td><td>Negative face along the z axis</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.FaceZ">FaceZ</a></td><td>zPositive</td><td>Positive face along the z axis</td></tr>
</table>
<p><h3>Modelica definition</h3>
<pre>
<font color="blue">model</font> SpeciesIncompressible <font color="darkgreen">&quot;Incompressible species&quot;</font>
  <font color="blue">extends </font><a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.Species">Species</a>(initMethPartNum=InitMethScalar.Volume);

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>SpeciesIncompressible;
</pre>
<hr>

<h2><img src="images/FCSys.Subregions.Species.SpeciesSolidI.png" alt="FCSys.Subregions.Species.Species" align=RIGHT border=1 width=80  height=80 >
<a name="FCSys.Subregions.Species.Species"></a><a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species">FCSys.Subregions.Species</a>.Species</h2>
<b>Model for single-species exchange, transport, and storage of material, linear momentum, and energy</b><p>
<img src="images/FCSys.Subregions.Species.SpeciesSolidD.png" alt="FCSys.Subregions.Species.Species">
<p><h3>Information</h3></p>

    <p>This model is based on the following fixed assumptions.  Other assumptions are
    optional via the parameters.
    <ol>
       <li>All faces are rectangular.
       <li>The material is orthorhombic.  This implies that a
          gradient which induces diffusion along an axis does not induce
          diffusion along axes orthogonal to it
          [<a href="FCSys_UsersGuide.html#FCSys.UsersGuide.References">Bejan2006</a>,
          pp. 691&ndash;692].</li>
       <li>The coordinate system (x, y, z) is aligned with the principle
          axes of transport.  For example, if the species is stratified, the
          layers must be parallel to one of the planes in the rectilinear
          grid.</li>
       <li>The factors that may cause anisotropic behavior (<b><i>k</i></b>)
          are common to material, mechanical, and thermal transport.</li>
       <li>There are no body or inertial forces (e.g., gravity).</li>
    </ol>
    </p>

    <p>Figure 1 shows the manner in which instances of
    <a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species">Species</a> models (derived from this
    model) are
    connected within a <a href="FCSys_Subregions.html#FCSys.Subregions">Subregion</a>.  The
    generalized resistances (<i>R</i>) affect the flow rates of linear momentum and
    heat associated with differences in velocity and temperature (respectively) between
    each species and a common node.  This exchange is diffusive.

    <p>Linear momentum and enthalpy are advected as material is exchanged in a chemical
    reaction.  This occurs at the velocity and massic enthalpy of the reactants (source
    species).  Resistance is not involved directly.  When the species are connected through
    a <a href="FCSys_Subregions.html#FCSys.Subregions.Reaction">Reaction</a> model, the material
    states are directly coupled according to the chemical equilibrium of the reaction.
    This reduces the DAE index by one.  The reaction rate is determined solely by
    the dynamics of the transport equations.</p>

    <p align=center><img src="images/exchange.png">
<br><b>Figure 1:</b>  Exchange of a quantity (linear momentum or heat) among species
    (A, B, and C) within a subregion.</p>

    <p>Figure 2 shows how <a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species">Species</a>
    instances of the same type are connected between neighboring
    <a href="FCSys_Subregions.html#FCSys.Subregions.Subregion">Subregion</a> instances.  Material,
    linear momentum, and heat are transported by both advection and diffusion.
    Upstream discretization is applied if it is enabled (via the <code>upstreamX</code>,
    etc. parameters).</p>

    <p align=center><img src="images/transport.png">
<br><b>Figure 2:</b>  Transport of a quantity associated with the same species
    between subregions (1 and 2).</p>

    <p>Within a phase, <a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species">Species</a> instances
    are combined by Dalton's law (see the
    <a href="FCSys_Connectors.html#FCSys.Connectors.InertDalton">InertDalton</a> connector), as shown
    in Figure 3a.  The pressures are additive, and each species is assumed to exist at the
    volume of the phase.  Within a subregion, phases are combined by Amagat's law (see the
    <a href="FCSys_Connectors.html#FCSys.Connectors.InertAmagat">InertAmagat</a> connector), as shown
    in Figure 3b.  The volumes are additive, and each species is assumed to exist at the
    pressure of the subregion.</p>

    <table border=0 cellspacing=0 cellpadding=2 align=center class=noBorder style="margin-left: auto; margin-right: auto;">
      <tr align=center class=noBorder>
        <td align=center class=noBorder style="margin-left: auto; margin-right: auto;">
          <img src="images/share_pressure.png">
<br><b>a:</b>  Pressures of species (A, B, and C) are additive within a phase.
        </td>
        <td align=center class=noBorder style="margin-left: auto; margin-right: auto;">
          <img src="images/share_volume.png">
<br><b>b:</b>  Volumes of phases (I, II, and III) are additive within a subregion.
        </td>
      </tr>
      <tr align=center class=noBorder style="margin-left: auto; margin-right: auto;">
        <td colspan=2 align=center class=noBorder ><b>Figure 3:</b> Methods of sharing pressure and volume.</td>
      </tr>
    </table>

    <p> The following notes apply to the parameters:
    <ul>
    <li>The "specific" adjective is taken to mean a quantity divided by particle
    number.  ("Massic" would indicate a quantity divided by mass.)</li>
    <li>In general, if fusivity, fluidity, or thermal resistivity is zero, then
    it should be set as <code>final</code> so that index reduction may be performed.
    If two <a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species">Species</a> instances
    are connected through their exchange connectors
    (<code>chemical</code> or <code>inert</code>) or faces (<code>xNegative</code>, <code>xPositive</code>, etc.) and both have zero resistivities for a
    quantity, then index reduction is necessary.</li>
    <li>Even if an initialization parameter is not selected for explicit use,
    it may be used a guess value.</li>
    <li>The <b><i>k</i></b> factor can be used to account for the effects of porosity and tortousity
    on transport.
    It should be changed directly with effective area and inversely with effective length.
    The factor may reflect anisotropic properties; it is a vector with independent components
    for each axis. It affects all of the diffusive transport rates (material, mechanical, and
    thermal) by the same factor.  By default, its components are unity.</li>
    <li>By default, only the x-axis component of linear momentum is included.  Also by default,
    only material and thermal transport are included through the x-axis faces and only
    x-axis displacement/shear stress is included through the y- and z-axis faces.</li>
    <li>By default, faces are assumed to be isobaric and inviscid if the corresponding 
    component of linear momentum is disabled.</li>
    <li>If a state is prescribed, then the
    associated initial condition (IC) will be applied for all time.  The
    corresponding conservation equation will not be imposed.
    If <code>setPartNum</code>, <code>setVelX</code>, <code>setVelY</code>, or <code>setVelZ</code> is
    <code>true</code>, then there may be a secondary effect on the energy conservation equation
    and thus temperature.
    In that case, it may be helpful to set <code>setTemp</code> to <code>true</code> so that
    the energy conservation equation is not imposed.</li>
    <li>If a subregion does not contain any compressible species, then pressure must be prescribed.
    Set <code>setPartNum</code> to <code>true</code> and <code>initMethPartNum</code>
    to <code>InitMethScalar.Pressure</code> for the species.  In general, only one incompressible
    species can be included if there are no incompressible species.</li>
    <li>The <code>start</code> values of the initial conditions for pressure and temperature
    (<i>p</i><sub>IC</sub> and <i>T</i><sub>IC</sub>) are the global default pressure and
    temperature (via the <code>outer</code> instance of the <a href="FCSys_BCs.html#FCSys.BCs.Environment">Environment</a> model).
    The <code>start</code> values of the initial conditions for
    other intensive properties (&rho;<sub>IC</sub>, <i>s</i><sub>IC</sub>, <i>h</i><sub>IC</sub>, and
    &mu;<sub>IC</sub>) are related to the initial pressure and temperature
    by the characteristics of the species.  The <code>start</code> value of the
    initial condition for the extensive volume (<i>V</i><sub>IC</sub>) is the volume of the
    subregion, and the <code>start</code> value for particle number (<i>N</i><sub>IC</sub>)
    is related to it via the characteristics (in <code>Data</code>) and the initial pressure and temperature.
    In order to apply other values for any of these initial conditions,
    it may be necessary to do so before translating the model.</li>
    <li>With the <code>overrideEOS</code> parameter, it is possible to specify that
    the volumic amount (i.e., molar concentration) and thus the amount or particle number is
    zero.
    Set <code>overrideEOS = true</code> and <code>rho_IC = 0</code>; then,
    the states for material, linear momentum, and energy will be eliminated.  If a species
    is included with this setting, then there must be an external reference
    for electrochemical potential (i.e., ground).  There must be at least one other
    species in the subregion or the velocity must be set (e.g.,
    <code>setVelX = true</code>).</li>
    </p>

    <p>In evaluating the dynamics of a phase, it is usually assumed that all of the species
    exist at the same temperature and bulk velocity.  The time constants that govern the
    temperatures/heat capacities of the species and heat flow rates among them are usually
    much shorter than the time span of interest.
    This assumption can be applied in the model by connecting the <code>common</code>
    connectors of the species.  It will cause index reduction during translation.</p>

    <p>In the variables that relate to transport,
    the first index is the axis and the second index is the side.  The sides
    are ordered from negative to positive, according to the
    <a href="FCSys_BaseClasses.html#FCSys.BaseClasses.Side">Side</a> enumeration.
    Shear velocity and force are additionally indexed by
    the orientation of the momentum with respect to the face.
    The orientations are ordered in Cartesian space starting with the axis after the
    normal face, according to the
    <a href="FCSys_BaseClasses.html#FCSys.BaseClasses.Orientation">Orientation</a> enumeration.</p>
    <p>

<p><h3>Parameters</h3><p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Type</th><th>Name</th><th>Default</th><th>Description</th></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Geometry</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Length">Length</a></td><td>Lstar</td><td>&nbsp;</td><td>Characteristic length for exchange (<i>L</i><sup>&#9733;</sup>) [l]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">NumberAbsolute</a></td><td>k[Axis]</td><td>{1,1,1}</td><td>Area fill factor for transport (<b>k</b>) [1]</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Material properties</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Fusivity">Fusivity</a></td><td>Xi</td><td>Data.Xi(T, 1/rho)</td><td>Fusivity (&Xi;) [T/l2]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Fluidity">Fluidity</a></td><td>F</td><td>Data.F(T, 1/rho)</td><td>Fluidity [l.T/m]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.ResistivityThermal">ResistivityThermal</a></td><td>R</td><td>Data.R(T, 1/rho)</td><td>Thermal resistivity</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=4><b>Assumptions</b></td></tr>
<tr><td>Boolean</td><td>overrideEOS</td><td>false</td><td>Override the equation of state with the value of &rho;<sub>IC</sub></td></tr>
<tr><td>Boolean</td><td>inclLin[Axis]</td><td>{true,false,false}</td><td>true, if each component of linear momentum is included (<i>Do not adjust here.</i>)</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Axes with upstream discretization</td></tr>
<tr><td>Boolean</td><td>upstreamX</td><td>true</td><td>X</td></tr>
<tr><td>Boolean</td><td>upstreamY</td><td>true</td><td>Y</td></tr>
<tr><td>Boolean</td><td>upstreamZ</td><td>true</td><td>Z</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Prescribed states (via initialization parameters)</td></tr>
<tr><td>Boolean</td><td>setPartNum</td><td>false</td><td>Particle number</td></tr>
<tr><td>Boolean</td><td>setVelX</td><td>false</td><td>X-axis component of velocity</td></tr>
<tr><td>Boolean</td><td>setVelY</td><td>false</td><td>Y-axis component of velocity</td></tr>
<tr><td>Boolean</td><td>setVelZ</td><td>false</td><td>Z-axis component of velocity</td></tr>
<tr><td>Boolean</td><td>setTemp</td><td>false</td><td>Temperature</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Characteristics of the faces (click to edit)</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.FaceX">FaceX</a></td><td>xNegative</td><td>&nbsp;</td><td>Negative face along the x axis</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.FaceX">FaceX</a></td><td>xPositive</td><td>&nbsp;</td><td>Positive face along the x axis</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.FaceY">FaceY</a></td><td>yNegative</td><td>&nbsp;</td><td>Negative face along the y axis</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.FaceY">FaceY</a></td><td>yPositive</td><td>&nbsp;</td><td>Positive face along the y axis</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.FaceZ">FaceZ</a></td><td>zNegative</td><td>&nbsp;</td><td>Negative face along the z axis</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.FaceZ">FaceZ</a></td><td>zPositive</td><td>&nbsp;</td><td>Positive face along the z axis</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=4><b>Initialization</b></td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Scalar properties</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethScalar">InitMethScalar</a></td><td>initMethPartNum</td><td>InitMethScalar.Pressure</td><td>Method of initializing the particle number</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethScalar">InitMethScalar</a></td><td>initMethTemp</td><td>InitMethScalar.Temperature</td><td>Method of initializing the temperature</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Amount">Amount</a></td><td>N_IC</td><td>&nbsp;</td><td>Initial particle number (<i>N</i><sub>IC</sub>) [N]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Current">Current</a></td><td>derN_IC</td><td>0</td><td>Initial rate of particle number ((&part;<i>N</i>/&part;<i>t</i>)<sub>IC</sub>) [N/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.AmountVolumic">AmountVolumic</a></td><td>rho_IC</td><td>&nbsp;</td><td>Initial volumic amount (&rho;<sub>IC</sub>) [N/l3]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.AmountVolumicRate">AmountVolumicRate</a></td><td>derrho_IC</td><td>0</td><td>Initial rate of volumic amount ((&part;&rho;/&part;<i>t</i>)<sub>IC</sub>) [N/(l3.T)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Volume">Volume</a></td><td>V_IC</td><td>&nbsp;</td><td>Initial volume (<i>V</i><sub>IC</sub>) [l3]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.VolumeRate">VolumeRate</a></td><td>derV_IC</td><td>0</td><td>Initial rate of volume ((&part;<i>V</i>/&part;<i>t</i>)<sub>IC</sub>) [l3/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PressureAbsolute">PressureAbsolute</a></td><td>p_IC</td><td>&nbsp;</td><td>Initial pressure (<i>p</i><sub>IC</sub>) [m/(l.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PressureRate">PressureRate</a></td><td>derp_IC</td><td>0</td><td>Initial rate of pressure ((&part;<i>p</i>/&part;<i>t</i>)<sub>IC</sub>) [m/(l.T3)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureAbsolute">TemperatureAbsolute</a></td><td>T_IC</td><td>&nbsp;</td><td>Initial temperature (<i>T</i><sub>IC</sub>)</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureRate">TemperatureRate</a></td><td>derT_IC</td><td>0</td><td>Initial rate of temperature (&part;<i>T</i>/&part;<i>t</i>)<sub>IC</sub>)</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">NumberAbsolute</a></td><td>s_IC</td><td>&nbsp;</td><td>Initial specific entropy (<i>s</i><sub>IC</sub>) [1]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.NumberRate">NumberRate</a></td><td>ders_IC</td><td>0</td><td>Initial rate of specific entropy ((&part;<i>s</i>/&part;<i>t</i>)<sub>IC</sub>) [1/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Potential</a></td><td>h_IC</td><td>&nbsp;</td><td>Initial specific enthalpy (<i>h</i><sub>IC</sub>) [l2.m/(N.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PotentialRate">PotentialRate</a></td><td>derh_IC</td><td>0</td><td>Initial rate of specific enthalpy ((&part;<i>h</i>/&part;<i>t</i>)<sub>IC</sub>) [l2.m/(N.T3)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Potential</a></td><td>mu_IC</td><td>&nbsp;</td><td>Initial electrochemical potential (&mu;<sub>IC</sub>) [l2.m/(N.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PotentialRate">PotentialRate</a></td><td>dermu_IC</td><td>0</td><td>Initial rate of electrochemical potential ((&part;&mu;/&part;<i>t</i>)<sub>IC</sub>) [l2.m/(N.T3)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Current">Current</a></td><td>Ndot_IC</td><td>0</td><td>Initial reaction rate (<i>N&#775;</i><sub>IC</sub>) [N/T]</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Velocity</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">InitMethVelocity</a></td><td>initMethX</td><td>InitMethVelocity.Velocity</td><td>Method of initializing the x-axis component</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">InitMethVelocity</a></td><td>initMethY</td><td>InitMethVelocity.Velocity</td><td>Method of initializing the y-axis component</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">InitMethVelocity</a></td><td>initMethZ</td><td>InitMethVelocity.Velocity</td><td>Method of initializing the z-axis component</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Velocity">Velocity</a></td><td>phi_IC[Axis]</td><td>{0,0,0}</td><td>Initial velocity (<b>&phi;</b><sub>IC</sub>) [l/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Acceleration">Acceleration</a></td><td>derphi_IC[Axis]</td><td>{0,0,0}</td><td>Initial acceleration ((&part;<b>&phi;</b>/&part;<i>t</i>)<sub>IC</sub>) [l/T2]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Current">Current</a></td><td>I_IC[Axis]</td><td>{0,0,0}</td><td>Initial current (<i><b>I</b></i><sub>IC</sub>) [N/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.CurrentRate">CurrentRate</a></td><td>derI_IC[Axis]</td><td>{0,0,0}</td><td>Initial rate of current ((&part;<i><b>I</b></i>/&part;<i>t</i>)<sub>IC</sub>) [N/T2]</td></tr>
</table>
<p><h3>Connectors</h3><p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Type</th><th>Name</th><th>Description</th></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.ChemicalOutput">ChemicalOutput</a></td><td>chemical</td><td>Connector to exchange material while advecting linear momentum and energy</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Inert">Inert</a></td><td>common</td><td>Connector for direct mechanical and thermal coupling of multiple species</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.InertDalton">InertDalton</a></td><td>inert</td><td>Connector to exchange linear momentum and heat by diffusion, with additivity of pressure</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=3><b>Assumptions</b></td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=3>Characteristics of the faces (click to edit)</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.FaceX">FaceX</a></td><td>xNegative</td><td>Negative face along the x axis</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.FaceX">FaceX</a></td><td>xPositive</td><td>Positive face along the x axis</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.FaceY">FaceY</a></td><td>yNegative</td><td>Negative face along the y axis</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.FaceY">FaceY</a></td><td>yPositive</td><td>Positive face along the y axis</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.FaceZ">FaceZ</a></td><td>zNegative</td><td>Negative face along the z axis</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.FaceZ">FaceZ</a></td><td>zPositive</td><td>Positive face along the z axis</td></tr>
</table>
<p><h3>Modelica definition</h3>
<pre>
<font color="blue">model</font> Species <font color="darkgreen">
  &quot;Model for single-species exchange, transport, and storage of material, linear momentum, and energy&quot;</font>
  <font color="darkgreen">//extends FCSys.BaseClasses.Icons.Names.Top1;</font>

  <font color="darkgreen">// Geometric parameters</font>
  <font color="blue">outer </font><font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Length">Q.Length</a> L[Axis](<font color="blue">each </font>min=Modelica.Constants.small) <font color="darkgreen">&quot;Length&quot;</font>;
  <font color="blue">outer </font><font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Area">Q.Area</a> A[Axis] <font color="darkgreen">&quot;Cross-sectional area&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Length">Q.Length</a> Lstar(
    min=Modelica.Constants.small,
    nominal=10*U.m,
    start=1e3*<font color="red">product</font>(L)^(1/3)) <font color="darkgreen">
    &quot;Characteristic length for exchange (<i>L</i><sup>&#9733;</sup>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">Q.NumberAbsolute</a> k[Axis](
    <font color="blue">each </font>min=Modelica.Constants.small,
    <font color="blue">each </font><font color="blue">final </font>nominal=1) = {1,1,1} <font color="darkgreen">
    &quot;Area fill factor for transport (<b>k</b>)&quot;</font>;

  <font color="darkgreen">// Material properties</font>
  <font color="blue">replaceable </font><font color="blue">package</font> Data = <a href="FCSys_Characteristics_BaseClasses_Characteristic.html#FCSys.Characteristics.BaseClasses.Characteristic">FCSys.Characteristics.BaseClasses.Characteristic</a> <font color="blue">
    constrainedby </font>FCSys.Characteristics.BaseClasses.Characteristic <font color="darkgreen">
    &quot;Characteristic data&quot;</font>;

  <font color="darkgreen">// Assumptions</font>
  <font color="darkgreen">// -----------</font>
  <font color="darkgreen">// General</font>
  <font color="blue">parameter </font>Boolean overrideEOS=false <font color="darkgreen">
    &quot;Override the equation of state with the value of &rho;<sub>IC</sub>&quot;</font>;
  <font color="blue">parameter </font>Boolean inclLin[Axis]={true,false,false} <font color="darkgreen">
    &quot;true, if each component of linear momentum is included (<i>Do not adjust here.</i>)&quot;</font>;
  <font color="darkgreen">// Even though this parameter is set as final within the constrainedby</font>
  <font color="darkgreen">// clauses of the Phase models, Dymola 7.4 still shows it in the</font>
  <font color="darkgreen">// parameter dialog (hence the &quot;Do not adjust&quot;).</font>
  <font color="darkgreen">//</font>
  <font color="darkgreen">// Upstream discretization</font>
  <font color="blue">parameter </font>Boolean upstreamX=true <font color="darkgreen">&quot;X&quot;</font>;
  <font color="blue">parameter </font>Boolean upstreamY=true <font color="darkgreen">&quot;Y&quot;</font>;
  <font color="blue">parameter </font>Boolean upstreamZ=true <font color="darkgreen">&quot;Z&quot;</font>;
  <font color="darkgreen">//</font>
  <font color="darkgreen">// Dynamics</font>
  <font color="blue">parameter </font>Boolean setPartNum=false <font color="darkgreen">&quot;Particle number&quot;</font>;
  <font color="blue">parameter </font>Boolean setVelX=false <font color="darkgreen">&quot;X-axis component of velocity&quot;</font>;
  <font color="blue">parameter </font>Boolean setVelY=false <font color="darkgreen">&quot;Y-axis component of velocity&quot;</font>;
  <font color="blue">parameter </font>Boolean setVelZ=false <font color="darkgreen">&quot;Z-axis component of velocity&quot;</font>;
  <font color="blue">parameter </font>Boolean setTemp=false <font color="darkgreen">&quot;Temperature&quot;</font>;

  <font color="darkgreen">// Initialization parameters for scalar properties</font>
  <font color="blue">parameter </font><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethScalar">BaseClasses.InitMethScalar</a> initMethPartNum=InitMethScalar.Pressure <font color="darkgreen">
    &quot;Method of initializing the particle number&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethScalar">BaseClasses.InitMethScalar</a> initMethTemp=InitMethScalar.Temperature <font color="darkgreen">
    &quot;Method of initializing the temperature&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Amount">Q.Amount</a> N_IC(start=V_IC*rho_IC) <font color="darkgreen">
    &quot;Initial particle number (<i>N</i><sub>IC</sub>)&quot;</font>;
  <font color="darkgreen">// Note:  This parameter is left enabled even it isn&#39;t used to</font>
  <font color="darkgreen">// explicitly initialize any states, since it&#39;s used as a guess value.</font>
  <font color="darkgreen">// Similar notes apply to some other initial conditions below.</font>
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Current">Q.Current</a> derN_IC=0 <font color="darkgreen">
    &quot;Initial rate of particle number ((&part;<i>N</i>/&part;<i>t</i>)<sub>IC</sub>)&quot;</font>;
  <font color="darkgreen">// Note:  Dymola 7.4 doesn&#39;t recognize enumerations in the dialog enable</font>
  <font color="darkgreen">// option, e.g.,</font>
  <font color="darkgreen">//     enable=initMethPartNum == InitMethScalar.AmountRate.</font>
  <font color="darkgreen">// Therefore, the values of the enumerations are specified numerically for</font>
  <font color="darkgreen">// this initial condition and some others below.</font>
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.AmountVolumic">Q.AmountVolumic</a> rho_IC(min=<font color="blue">if </font>overrideEOS<font color="blue"> then </font>0<font color="blue"> else </font>Modelica.Constants.small,
      start=1/<font color="red">Data.v_Tp</font>(T_IC, p_IC)) <font color="darkgreen">
    &quot;Initial volumic amount (&rho;<sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.AmountVolumicRate">Q.AmountVolumicRate</a> derrho_IC=0 <font color="darkgreen">
    &quot;Initial rate of volumic amount ((&part;&rho;/&part;<i>t</i>)<sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Volume">Q.Volume</a> V_IC(start=<font color="red">product</font>(L)) <font color="darkgreen">
    &quot;Initial volume (<i>V</i><sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.VolumeRate">Q.VolumeRate</a> derV_IC=0 <font color="darkgreen">
    &quot;Initial rate of volume ((&part;<i>V</i>/&part;<i>t</i>)<sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.PressureAbsolute">Q.PressureAbsolute</a> p_IC(start=environment.p) <font color="darkgreen">
    &quot;Initial pressure (<i>p</i><sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.PressureRate">Q.PressureRate</a> derp_IC=0 <font color="darkgreen">
    &quot;Initial rate of pressure ((&part;<i>p</i>/&part;<i>t</i>)<sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureAbsolute">Q.TemperatureAbsolute</a> T_IC(nominal=298.15*U.K, start=environment.T)
    <font color="darkgreen">&quot;Initial temperature (<i>T</i><sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureRate">Q.TemperatureRate</a> derT_IC=0 <font color="darkgreen">
    &quot;Initial rate of temperature (&part;<i>T</i>/&part;<i>t</i>)<sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">Q.NumberAbsolute</a> s_IC(min=Modelica.Constants.small, start=<font color="red">Data.s</font>(T=
        T_IC, p=p_IC)) <font color="darkgreen">
    &quot;Initial specific entropy (<i>s</i><sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.NumberRate">Q.NumberRate</a> ders_IC=0 <font color="darkgreen">
    &quot;Initial rate of specific entropy ((&part;<i>s</i>/&part;<i>t</i>)<sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Q.Potential</a> h_IC(start=<font color="red">Data.h</font>(T_IC, p_IC)) <font color="darkgreen">
    &quot;Initial specific enthalpy (<i>h</i><sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.PotentialRate">Q.PotentialRate</a> derh_IC=0 <font color="darkgreen">
    &quot;Initial rate of specific enthalpy ((&part;<i>h</i>/&part;<i>t</i>)<sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Q.Potential</a> mu_IC(start=<font color="red">Data.g</font>(T_IC, p_IC)) <font color="darkgreen">
    &quot;Initial electrochemical potential (&mu;<sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.PotentialRate">Q.PotentialRate</a> dermu_IC=0 <font color="darkgreen">
    &quot;Initial rate of electrochemical potential ((&part;&mu;/&part;<i>t</i>)<sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Current">Q.Current</a> Ndot_IC=0 <font color="darkgreen">
    &quot;Initial reaction rate (<i>N&#775;</i><sub>IC</sub>)&quot;</font>;

  <font color="darkgreen">// Initialization parameters for velocity</font>
  <font color="blue">parameter </font><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">BaseClasses.InitMethVelocity</a> initMethX=InitMethVelocity.Velocity <font color="darkgreen">
    &quot;Method of initializing the x-axis component&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">BaseClasses.InitMethVelocity</a> initMethY=InitMethVelocity.Velocity <font color="darkgreen">
    &quot;Method of initializing the y-axis component&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">BaseClasses.InitMethVelocity</a> initMethZ=InitMethVelocity.Velocity <font color="darkgreen">
    &quot;Method of initializing the z-axis component&quot;</font>;
  <font color="darkgreen">// Note:  Dymola 7.4 doesn&#39;t provide pull-down lists for arrays of</font>
  <font color="darkgreen">// enumerations; therefore, a parameter is used for each axis.</font>
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Velocity">Q.Velocity</a> phi_IC[Axis]={0,0,0} <font color="darkgreen">
    &quot;Initial velocity (<b>&phi;</b><sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Acceleration">Q.Acceleration</a> derphi_IC[Axis]={0,0,0} <font color="darkgreen">
    &quot;Initial acceleration ((&part;<b>&phi;</b>/&part;<i>t</i>)<sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Current">Q.Current</a> I_IC[Axis]={0,0,0} <font color="darkgreen">
    &quot;Initial current (<i><b>I</b></i><sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.CurrentRate">Q.CurrentRate</a> derI_IC[Axis]={0,0,0} <font color="darkgreen">
    &quot;Initial rate of current ((&part;<i><b>I</b></i>/&part;<i>t</i>)<sub>IC</sub>)&quot;</font>;

  <font color="darkgreen">// Material properties</font>
  <a href="FCSys_Quantities.html#FCSys.Quantities.Fusivity">Q.Fusivity</a> Xi(nominal=1*U.s/U.cm^2) = <font color="red">Data.Xi</font>(T, 1/rho) <font color="darkgreen">
    &quot;Fusivity (&Xi;)&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Fluidity">Q.Fluidity</a> F(nominal=10*U.cm*U.s/U.g) = <font color="red">Data.F</font>(T, 1/rho) <font color="darkgreen">&quot;Fluidity&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.ResistivityThermal">Q.ResistivityThermal</a> R(nominal=10*U.cm/U.A) = <font color="red">Data.R</font>(T, 1/rho) <font color="darkgreen">
    &quot;Thermal resistivity&quot;</font>;

  <font color="darkgreen">// Preferred states</font>
  <a href="FCSys_Quantities.html#FCSys.Quantities.Amount">Q.Amount</a> N(
    nominal=1*U.mol,
    <font color="blue">final </font>start=N_IC,
    <font color="blue">final </font>fixed=false,
    stateSelect=StateSelect.default) <font color="darkgreen">&quot;Particle number&quot;</font>;
  <font color="darkgreen">// Note:  The start value for this variable (and others below) isn&#39;t fixed</font>
  <font color="darkgreen">// because the related initial condition is applied in the initial</font>
  <font color="darkgreen">// equation section.</font>
  <a href="FCSys_Quantities.html#FCSys.Quantities.Velocity">Q.Velocity</a> phi[n_lin](
    <font color="blue">each </font>nominal=1*U.cm/U.s,
    <font color="blue">final </font>start=phi_IC[cartAxes],
    <font color="blue">each </font><font color="blue">final </font>fixed=false,
    <font color="blue">each </font>stateSelect=StateSelect.prefer) <font color="darkgreen">&quot;Velocity&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureAbsolute">Q.TemperatureAbsolute</a> T(
    nominal=298.15*U.K,
    <font color="blue">final </font>start=T_IC,
    <font color="blue">final </font>fixed=false,
    stateSelect=StateSelect.prefer) <font color="darkgreen">&quot;Temperature&quot;</font>;

  <font color="darkgreen">// Aliases (for common terms)</font>
  <a href="FCSys_Quantities.html#FCSys.Quantities.Mass">Q.Mass</a> M(nominal=1*U.g, start=Data.m*N_IC) <font color="darkgreen">&quot;Mass&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Volume">Q.Volume</a> V(
    nominal=1*U.cm^3,
    <font color="blue">final </font>start=V_IC,
    <font color="blue">final </font>fixed=false) <font color="darkgreen">&quot;Volume&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.PressureAbsolute">Q.PressureAbsolute</a> p(
    nominal=1*U.atm,
    <font color="blue">final </font>start=p_IC,
    <font color="blue">final </font>fixed=false) <font color="darkgreen">&quot;Pressure&quot;</font>;
  <font color="darkgreen">// **stateSelect=StateSelect.never</font>
  <font color="darkgreen">// Note:  In Dymola 7.4 StateSelect.never is necessary to avoid dynamic</font>
  <font color="darkgreen">// state selection.  **Is it still?</font>
  <a href="FCSys_Quantities.html#FCSys.Quantities.AmountVolumic">Q.AmountVolumic</a> rho(
    nominal=4*U.C/U.cm^3,
    <font color="blue">final </font>start=rho_IC,
    <font color="blue">final </font>fixed=false) <font color="darkgreen">&quot;Molar density&quot;</font>;
  <font color="darkgreen">// Note:  The reciprocal, specific volume (v), isn&#39;t included because</font>
  <font color="darkgreen">// particle number (N) can be zero.</font>
  <a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Q.Potential</a> h(
    nominal=1*U.V,
    <font color="blue">final </font>start=h_IC,
    <font color="blue">final </font>fixed=false) <font color="darkgreen">&quot;Specific enthalpy&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">Q.NumberAbsolute</a> s(
    nominal=10,
    <font color="blue">final </font>start=s_IC,
    <font color="blue">final </font>fixed=false) <font color="darkgreen">&quot;Specific entropy&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Q.Potential</a> mu(
    nominal=1*U.V,
    <font color="blue">final </font>start=mu_IC,
    <font color="blue">final </font>fixed=false) <font color="darkgreen">&quot;Electrochemical potential&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Current">Q.Current</a> I[n_lin](
    <font color="blue">each </font>nominal=1*U.A,
    <font color="blue">final </font>start=I_IC[cartAxes],
    <font color="blue">each </font><font color="blue">final </font>fixed=false) <font color="darkgreen">&quot;Current&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.CapacityThermalSpecific">Q.CapacityThermalSpecific</a> c_V <font color="darkgreen">&quot;Isochoric specific heat capacity&quot;</font>;

  <font color="darkgreen">// Auxiliary variables (for analysis)</font>
  <font color="darkgreen">// ----------------------------------</font>
  <font color="darkgreen">// Misc. properties and conditions</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.PressureAbsolute">Q.PressureAbsolute</a> q[n_lin](<font color="blue">each </font>stateSelect=StateSelect.never) = Data.m
    *phi .* I ./ (2*A[cartAxes]) <font color="blue">if </font>environment.analysis <font color="darkgreen">&quot;Dynamic pressure&quot;</font>;
  <font color="darkgreen">//</font>
  <font color="darkgreen">// Capacitances</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Capacitance">Q.Capacitance</a> C(stateSelect=StateSelect.never) = <font color="blue">if </font>Data.isCompressible<font color="blue">
     and </font><font color="blue">not </font>overrideEOS<font color="blue"> then </font>-N*rho^2*(U.m^3/U.C)/<font color="red">Data.dp</font>(
    v=1/rho,
    T=T,
    dv=U.m^3/U.C,
    dT=0)<font color="blue"> else </font>0 <font color="blue">if </font>environment.analysis <font color="darkgreen">&quot;Chemical capacitance&quot;</font>;
  <font color="darkgreen">// Note:  This is delN/delg at constant T and V.</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.CapacityThermal">Q.CapacityThermal</a> C_V(stateSelect=StateSelect.never) = N*c_V <font color="blue">if </font>
    environment.analysis <font color="darkgreen">&quot;Isochoric heat capacity&quot;</font>;
  <font color="darkgreen">//</font>
  <font color="darkgreen">// Time constants</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Time">Q.Time</a> tau_exch_mechanical(stateSelect=StateSelect.never) = alpha_F*N/
    Lstar <font color="blue">if </font>environment.analysis <font color="darkgreen">&quot;Time constant for mechanical exchange&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Time">Q.Time</a> tau_exch_thermal(stateSelect=StateSelect.never) = alpha_R*N/
    Lstar <font color="blue">if </font>environment.analysis <font color="darkgreen">&quot;Time constant for thermal exchange&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Time">Q.Time</a> tau_trans_mat[Axis](<font color="blue">each </font>stateSelect=StateSelect.never) = <font color="red">fill</font>(
    alpha_Xi*N, 3) ./ Lstar_trans <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Time constants for material transport&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Time">Q.Time</a> tau_trans_mech[Axis](<font color="blue">each </font>stateSelect=StateSelect.never) = <font color="red">fill</font>
    (alpha_F*N, 3) ./ Lstar_trans <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Time constants for mechanical transport&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Time">Q.Time</a> tau_trans_therm[Axis](<font color="blue">each </font>stateSelect=StateSelect.never) = <font color="red">
    fill</font>(alpha_R*N, 3) ./ Lstar_trans <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Time constants for thermal transport&quot;</font>;
  <font color="darkgreen">//</font>
  <font color="darkgreen">// Peclet numbers (only for the axes with linear momentum included; others are</font>
  <font color="darkgreen">// zero)</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Number">Q.Number</a> Pe_mat[n_lin](<font color="blue">each </font>stateSelect=StateSelect.never) = I*
    alpha_Xi ./ Lstar_trans[cartAxes] <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Material Peclet numbers&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Number">Q.Number</a> Pe_mech[n_lin](<font color="blue">each </font>stateSelect=StateSelect.never) = I*
    alpha_F ./ Lstar_trans[cartAxes] <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Mechanical Peclet numbers&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Number">Q.Number</a> Pe_therm[n_lin](<font color="blue">each </font>stateSelect=StateSelect.never) = I*
    alpha_R ./ Lstar_trans[cartAxes] <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Thermal Peclet numbers&quot;</font>;
  <font color="darkgreen">//</font>
  <font color="darkgreen">// Bulk flow rates</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> mphiI[n_lin, Orientation](<font color="blue">each </font>stateSelect=StateSelect.never)
     = {(<font color="blue">if </font>inclLin[<font color="red">cartWrap</font>(cartAxes[axis] + orientation)]<font color="blue"> then </font>Data.m*phi[
    linAxes[<font color="red">cartWrap</font>(cartAxes[axis] + orientation)]]*I[axis]<font color="blue"> else </font>0) <font color="blue">for </font>
    orientation<font color="blue"> in </font>Orientation, axis<font color="blue"> in </font>1:n_lin} <font color="blue">if </font>n_lin &gt; 0<font color="blue"> and </font>environment.analysis
    <font color="darkgreen">&quot;Bulk rate of mechanical advection&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> TsI[n_lin](<font color="blue">each </font>stateSelect=StateSelect.never) = T*s*I <font color="blue">if </font>
    environment.analysis <font color="darkgreen">&quot;Bulk rate of thermal advection&quot;</font>;
  <font color="darkgreen">//</font>
  <font color="darkgreen">// Linear momentum balance</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> Ma[n_lin](<font color="blue">each </font>stateSelect=StateSelect.never) = M*(<font color="red">der</font>(phi)/U.s
     - environment.a[cartAxes]) <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Acceleration force relative to the frame of reference (constant mass)&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> f_exch_adv[n_lin](<font color="blue">each </font>stateSelect=StateSelect.never) =
    chemical.mPhidot - Data.m*phi*chemical.Ndot <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Acceleration force due to material (advective) exchange&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> f_exch_diff[n_lin](<font color="blue">each </font>stateSelect=StateSelect.never) =
    common.mechanical.mPhidot + inert.mPhidot <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Friction from other species (diffusive exchange)&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> f_trans_adv[n_lin](<font color="blue">each </font>stateSelect=StateSelect.never) = {Data.m
    *<font color="red">Delta</font>(<font color="red">Data.v_Tp</font>(T_face[cartAxes[axis], :], p_face[cartAxes[axis], :]) .*
    Ndot_face[cartAxes[axis], :] .^ 2)/A[cartAxes[axis]] + <font color="red">sum</font>(Data.m*<font color="red">Sigma</font>(
    phi_face[<font color="red">cartWrap</font>(cartAxes[axis] - orientation), :, orientation] .*
    Ndot_face[<font color="red">cartWrap</font>(cartAxes[axis] - orientation), :]) <font color="blue">for </font>orientation<font color="blue"> in </font>
    Orientation) <font color="blue">for </font>axis<font color="blue"> in </font>1:n_lin} <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Acceleration force due to material (advective) transport&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> f_trans_diff[n_lin](<font color="blue">each </font>stateSelect=StateSelect.never) = {A[
    cartAxes[axis]]*<font color="red">Delta</font>(p_face[cartAxes[axis], :]) + <font color="red">sum</font>(<font color="red">Sigma</font>(mPhidot_face[<font color="red">
    cartWrap</font>(cartAxes[axis] - orientation), :, orientation]) <font color="blue">for </font>orientation<font color="blue">
     in </font>Orientation) <font color="blue">for </font>axis<font color="blue"> in </font>1:n_lin} <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Friction from other subregions (diffusive transport; includes volume viscosity)&quot;</font>;
  <font color="darkgreen">//</font>
  <font color="darkgreen">// Energy balance</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> Ndere(stateSelect=StateSelect.never) = (N*(<font color="red">der</font>(h) + Data.m*<font color="red">der</font>
    (phi*phi)/2) - V*<font color="red">der</font>(p))/U.s <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Rate of energy storage (internal and kinetic) at constant mass&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> Wdot_exch(stateSelect=StateSelect.never) = -((Data.m*(chemical.hbar
     - phi*phi/2) - h)*chemical.Ndot + chemical.phi*chemical.mPhidot/2) <font color="blue">if </font>
    environment.analysis <font color="darkgreen">
    &quot;Relative rate of work (internal, flow, and kinetic) done by chemical exchange (advection)&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> Qdot_gen_exch(stateSelect=StateSelect.never) = phi*common.mechanical.mPhidot
     + inert.phi*inert.mPhidot <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Rate of heat generation due to friction with other species&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> Qdot_exch(stateSelect=StateSelect.never) = common.thermal.Qdot +
    inert.Qdot <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Rate of thermal conduction from other species&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> Wdot_trans(stateSelect=StateSelect.never) = -<font color="red">sum</font>(<font color="red">sum</font>((<font color="red">Data.h</font>(
    T_face[axis, side], p_face[axis, side]) + Data.m*((<font color="red">Data.v_Tp</font>(T_face[axis,
    side], p_face[axis, side])*Ndot_face[axis, side]/A[axis])^2 + phi_face[axis,
    side, :]*phi_face[axis, side, :])/2 - h - Data.m*phi*phi/2)*Ndot_face[axis,
    side] <font color="blue">for </font>side<font color="blue"> in </font>Side) <font color="blue">for </font>axis<font color="blue"> in </font>Axis) <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Relative rate of work (internal, flow, and kinetic) done by material transport (advection)&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> Qdot_gen_trans(stateSelect=StateSelect.never) = <font color="red">sum</font>(phi_face .*
    mPhidot_face) <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Rate of heat generation due to friction with other subregions&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> Qdot_trans(stateSelect=StateSelect.never) = <font color="red">sum</font>(Qdot_face) <font color="blue">if </font>
    environment.analysis <font color="darkgreen">&quot;Rate of thermal conduction from other subregions&quot;</font>;
  <font color="darkgreen">// Note:  These auxiliary variables should not be used as states; the</font>
  <font color="darkgreen">// structure of the problem should not change if they are included.</font>

<textblock type="annotcomp" expanded="false">  <a href="FCSys_Connectors.html#FCSys.Connectors.ChemicalOutput">FCSys.Connectors.ChemicalOutput</a> chemical(
    <font color="blue">final </font>n_lin=n_lin,
    <font color="blue">final </font>m=Data.m,
    <font color="blue">final </font>formula=Data.formula,
    muPerT(<font color="blue">final </font>start=mu_IC/T_IC),
    phi(<font color="blue">final </font>start=phi_IC[cartAxes]),
    Ndot(<font color="blue">final </font>start=Ndot_IC,<font color="blue">final </font>fixed=false),
    hbar(<font color="blue">final </font>start=<font color="red">Data.h</font>(T_IC, p_IC)/Data.m, <font color="blue">final </font>fixed=false)) <font color="darkgreen">
    &quot;Connector to exchange material while advecting linear momentum and energy&quot;</font>;
  <a href="FCSys_Connectors.html#FCSys.Connectors.Inert">FCSys.Connectors.Inert</a> common(
    <font color="blue">final </font>n_lin=n_lin,
    mechanical(phi(<font color="blue">final </font>start=phi_IC[cartAxes], <font color="blue">each </font><font color="blue">final </font>fixed=false)),
    thermal(T(<font color="blue">final </font>start=T_IC,<font color="blue">final </font>fixed=false))) <font color="darkgreen">
    &quot;Connector for direct mechanical and thermal coupling of multiple species&quot;</font>;
  <a href="FCSys_Connectors.html#FCSys.Connectors.InertDalton">FCSys.Connectors.InertDalton</a> inert(
    <font color="blue">final </font>n_lin=n_lin,
    V(
      min=0,
      <font color="blue">final </font>start=V_IC,
      <font color="blue">final </font>fixed=false),
    p(<font color="blue">final </font>start=p_IC, <font color="blue">final </font>fixed=false),
    phi(start=phi_IC[cartAxes]),
    T(start=T_IC)) <font color="darkgreen">
    &quot;Connector to exchange linear momentum and heat by diffusion, with additivity of pressure&quot;</font>;
  <a href="FCSys_Connectors.html#FCSys.Connectors.FaceX">FCSys.Connectors.FaceX</a> xNegative(
    thermoOpt=<font color="blue">if </font>inclLin[Axis.x]<font color="blue"> then </font>ThermoOpt.OpenDiabatic<font color="blue"> else </font>ThermoOpt.ClosedDiabatic,

    inviscidY=<font color="blue">not </font>inclLin[Axis.y],
    inviscidZ=<font color="blue">not </font>inclLin[Axis.z],
    material(<font color="blue">final </font>rho(start=rho_IC) = rho_face[Axis.x, Side.n], <font color="blue">final </font>Ndot(
          start=I_IC[Axis.x]) = Ndot_face[Axis.x, Side.n]),
    mechanicalY(<font color="blue">final </font>phi(start=phi_IC[Axis.y]) = phi_face[Axis.x, Side.n,
        Orientation.following], <font color="blue">final </font>mPhidot=mPhidot_face[Axis.x, Side.n,
          Orientation.following]),
    mechanicalZ(<font color="blue">final </font>phi(start=phi_IC[Axis.z]) = phi_face[Axis.x, Side.n,
        Orientation.preceding], <font color="blue">final </font>mPhidot=mPhidot_face[Axis.x, Side.n,
          Orientation.preceding]),
    thermal(<font color="blue">final </font>T(start=T_IC) = T_face[Axis.x, Side.n],<font color="blue">final </font>Qdot(start=0) =
        Qdot_face[Axis.x, Side.n])) <font color="darkgreen">&quot;Negative face along the x axis&quot;</font>;</textblock>

<textblock type="annotcomp" expanded="false">  <a href="FCSys_Connectors.html#FCSys.Connectors.FaceX">FCSys.Connectors.FaceX</a> xPositive(
    thermoOpt=<font color="blue">if </font>inclLin[Axis.x]<font color="blue"> then </font>ThermoOpt.OpenDiabatic<font color="blue"> else </font>ThermoOpt.ClosedDiabatic,

    inviscidY=<font color="blue">not </font>inclLin[Axis.y],
    inviscidZ=<font color="blue">not </font>inclLin[Axis.z],
    material(<font color="blue">final </font>rho(start=rho_IC) = rho_face[Axis.x, Side.p], <font color="blue">final </font>Ndot(
          start=-I_IC[Axis.x]) = Ndot_face[Axis.x, Side.p]),
    mechanicalY(<font color="blue">final </font>phi(start=phi_IC[Axis.y]) = phi_face[Axis.x, Side.p,
        Orientation.following], <font color="blue">final </font>mPhidot=mPhidot_face[Axis.x, Side.p,
          Orientation.following]),
    mechanicalZ(<font color="blue">final </font>phi(start=phi_IC[Axis.z]) = phi_face[Axis.x, Side.p,
        Orientation.preceding], <font color="blue">final </font>mPhidot=mPhidot_face[Axis.x, Side.p,
          Orientation.preceding]),
    thermal(<font color="blue">final </font>T(start=T_IC) = T_face[Axis.x, Side.p],<font color="blue">final </font>Qdot(start=0) =
        Qdot_face[Axis.x, Side.p])) <font color="darkgreen">&quot;Positive face along the x axis&quot;</font>;</textblock>

<textblock type="annotcomp" expanded="false">  <a href="FCSys_Connectors.html#FCSys.Connectors.FaceY">FCSys.Connectors.FaceY</a> yNegative(
    thermoOpt=<font color="blue">if </font>inclLin[Axis.y]<font color="blue"> then </font>ThermoOpt.OpenDiabatic<font color="blue"> else </font>ThermoOpt.ClosedDiabatic,

    inviscidZ=<font color="blue">not </font>inclLin[Axis.z],
    inviscidX=<font color="blue">not </font>inclLin[Axis.x],
    material(<font color="blue">final </font>rho(start=rho_IC) = rho_face[Axis.y, Side.n], <font color="blue">final </font>Ndot(
          start=I_IC[Axis.y]) = Ndot_face[Axis.y, Side.n]),
    mechanicalZ(<font color="blue">final </font>phi(start=phi_IC[Axis.z]) = phi_face[Axis.y, Side.n, Side.n],
        <font color="blue">final </font>mPhidot=mPhidot_face[Axis.y, Side.n, Orientation.following]),
    mechanicalX(<font color="blue">final </font>phi(start=phi_IC[Axis.x]) = phi_face[Axis.y, Side.n, Side.p],
        <font color="blue">final </font>mPhidot=mPhidot_face[Axis.y, Side.n, Orientation.preceding]),
    thermal(<font color="blue">final </font>T(start=T_IC) = T_face[Axis.y, Side.n],<font color="blue">final </font>Qdot(start=0) =
        Qdot_face[Axis.y, Side.n])) <font color="darkgreen">&quot;Negative face along the y axis&quot;</font>;</textblock>

<textblock type="annotcomp" expanded="false">  <a href="FCSys_Connectors.html#FCSys.Connectors.FaceY">FCSys.Connectors.FaceY</a> yPositive(
    thermoOpt=<font color="blue">if </font>inclLin[Axis.y]<font color="blue"> then </font>ThermoOpt.OpenDiabatic<font color="blue"> else </font>ThermoOpt.ClosedDiabatic,

    inviscidZ=<font color="blue">not </font>inclLin[Axis.z],
    inviscidX=<font color="blue">not </font>inclLin[Axis.x],
    material(<font color="blue">final </font>rho(start=rho_IC) = rho_face[Axis.y, Side.p],<font color="blue">final </font>Ndot(
          start=-I_IC[Axis.y]) = Ndot_face[Axis.y, Side.p]),
    mechanicalZ(<font color="blue">final </font>phi(start=phi_IC[Axis.z]) = phi_face[Axis.y, Side.p,
        Orientation.following], <font color="blue">final </font>mPhidot=mPhidot_face[Axis.y, Side.p,
          Orientation.following]),
    mechanicalX(<font color="blue">final </font>phi(start=phi_IC[Axis.x]) = phi_face[Axis.y, Side.p,
        Orientation.preceding], <font color="blue">final </font>mPhidot=mPhidot_face[Axis.y, Side.p,
          Orientation.preceding]),
    thermal(<font color="blue">final </font>T(start=T_IC) = T_face[Axis.y, Side.p],<font color="blue">final </font>Qdot(start=0) =
        Qdot_face[Axis.y, Side.p])) <font color="darkgreen">&quot;Positive face along the y axis&quot;</font>;</textblock>

<textblock type="annotcomp" expanded="false">  <a href="FCSys_Connectors.html#FCSys.Connectors.FaceZ">FCSys.Connectors.FaceZ</a> zNegative(
    thermoOpt=<font color="blue">if </font>inclLin[Axis.z]<font color="blue"> then </font>ThermoOpt.OpenDiabatic<font color="blue"> else </font>ThermoOpt.ClosedDiabatic,

    inviscidX=<font color="blue">not </font>inclLin[Axis.x],
    inviscidY=<font color="blue">not </font>inclLin[Axis.y],
    material(<font color="blue">final </font>rho(start=rho_IC) = rho_face[Axis.z, Side.n], <font color="blue">final </font>Ndot(
          start=I_IC[Axis.z]) = Ndot_face[Axis.z, Side.n]),
    mechanicalX(<font color="blue">final </font>phi(start=phi_IC[Axis.x]) = phi_face[Axis.z, Side.n,
        Orientation.following], <font color="blue">final </font>mPhidot=mPhidot_face[Axis.z, Side.n,
          Orientation.following]),
    mechanicalY(<font color="blue">final </font>phi(start=phi_IC[Axis.y]) = phi_face[Axis.z, Side.n,
        Orientation.preceding], <font color="blue">final </font>mPhidot=mPhidot_face[Axis.z, Side.n,
          Orientation.preceding]),
    thermal(<font color="blue">final </font>T(start=T_IC) = T_face[Axis.z, Side.n],<font color="blue">final </font>Qdot(start=0) =
        Qdot_face[Axis.z, Side.n])) <font color="darkgreen">&quot;Negative face along the z axis&quot;</font>;</textblock>

<textblock type="annotcomp" expanded="false">  <a href="FCSys_Connectors.html#FCSys.Connectors.FaceZ">FCSys.Connectors.FaceZ</a> zPositive(
    thermoOpt=<font color="blue">if </font>inclLin[Axis.z]<font color="blue"> then </font>ThermoOpt.OpenDiabatic<font color="blue"> else </font>ThermoOpt.ClosedDiabatic,

    inviscidX=<font color="blue">not </font>inclLin[Axis.x],
    inviscidY=<font color="blue">not </font>inclLin[Axis.y],
    material(<font color="blue">final </font>rho(start=rho_IC) = rho_face[Axis.z, Side.p], <font color="blue">final </font>Ndot(
          start=-I_IC[Axis.z]) = Ndot_face[Axis.z, Side.p]),
    mechanicalX(<font color="blue">final </font>phi(start=phi_IC[Axis.x]) = phi_face[Axis.z, Side.p,
        Orientation.following], <font color="blue">final </font>mPhidot=mPhidot_face[Axis.z, Side.p,
          Orientation.following]),
    mechanicalY(<font color="blue">final </font>phi(start=phi_IC[Axis.y]) = phi_face[Axis.z, Side.p,
        Orientation.preceding], <font color="blue">final </font>mPhidot=mPhidot_face[Axis.z, Side.p,
          Orientation.preceding]),
    thermal(<font color="blue">final </font>T(start=T_IC) = T_face[Axis.z, Side.p],<font color="blue">final </font>Qdot(start=0) =
        Qdot_face[Axis.z, Side.p])) <font color="darkgreen">&quot;Positive face along the z axis&quot;</font>;</textblock>

  <font color="darkgreen">// Geometric parameters</font>
<font color="blue">protected </font>
  <font color="blue">final </font><font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Length">Q.Length</a> Lstar_trans[Axis]=k .* A ./ L <font color="darkgreen">
    &quot;Effective cross-sectional area per length&quot;</font>;
  <font color="blue">final </font><font color="blue">parameter </font>Integer n_lin=<font color="red">countTrue</font>(inclLin) <font color="darkgreen">
    &quot;Number of components of linear momentum&quot;</font>;
  <font color="blue">final </font><font color="blue">parameter </font>Integer cartAxes[n_lin]=<font color="red">index</font>(inclLin) <font color="darkgreen">
    &quot;Cartesian-axis indices of the axes of linear momentum&quot;</font>;
  <font color="blue">final </font><font color="blue">parameter </font>Integer linAxes[Axis]=<font color="red">enumerate</font>(inclLin) <font color="darkgreen">
    &quot;Linear momentum component indices of the Cartesian axes&quot;</font>;
  <font color="blue">final </font><font color="blue">parameter </font>Boolean upstream[Axis]={upstreamX,upstreamY,upstreamZ} <font color="darkgreen">
    &quot;true, if each Cartesian axis uses upstream discretization&quot;</font>;
  <font color="blue">final </font><font color="blue">parameter </font>Boolean setVel[Axis]={setVelX,setVelY,setVelZ} <font color="darkgreen">
    &quot;true, if each component of linear momentum is prescribed&quot;</font>;
  <font color="blue">final </font><font color="blue">parameter </font><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitMethVelocity">BaseClasses.InitMethVelocity</a> initMethVel[Axis]={initMethX,
      initMethY,initMethZ} <font color="darkgreen">&quot;Initialization methods for velocity&quot;</font>;

  <font color="darkgreen">// Base resistivity factors</font>
  <a href="FCSys_Quantities.html#FCSys.Quantities.Resistivity">Q.Resistivity</a> alpha_Xi(nominal=10*U.cm/U.A) = Xi/rho <font color="darkgreen">
    &quot;Base resistivity factor for fusivity&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Resistivity">Q.Resistivity</a> alpha_F(nominal=10*U.cm/U.A) = F*Data.m <font color="darkgreen">
    &quot;Base resistivity factor for fluidity&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Resistivity">Q.Resistivity</a> alpha_R(nominal=10*U.cm/U.A) = R*c_V <font color="darkgreen">
    &quot;Base resistivity factor for thermal resistivity&quot;</font>;

  <font color="darkgreen">// Efforts and flows of the conditional connectors</font>
  <a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> rho_face[Axis, Side](start=<font color="red">fill</font>(
        rho_IC,
        3,
        2)) <font color="darkgreen">&quot;Densities at the faces&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Pressure">Q.Pressure</a> p_face[Axis, Side](start=<font color="red">fill</font>(
        p_IC,
        3,
        2)) <font color="darkgreen">&quot;Pressures at the faces&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Current">Q.Current</a> Ndot_face[Axis, Side](start=<font color="red">outerProduct</font>(I_IC, {1,-1})) <font color="darkgreen">
    &quot;Currents into the faces&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Velocity">Q.Velocity</a> phi_face[Axis, Side, Orientation](start={{{<font color="blue">if </font>inclLin[<font color="red">cartWrap</font>(
        axis + orientation)]<font color="blue"> then </font>phi_IC[<font color="red">cartWrap</font>(axis + orientation)]<font color="blue"> else </font>0 <font color="blue">
        for </font>orientation<font color="blue"> in </font>Orientation} <font color="blue">for </font>side<font color="blue"> in </font>Side} <font color="blue">for </font>axis<font color="blue"> in </font>Axis}) <font color="darkgreen">
    &quot;Shear velocities at the faces&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> mPhidot_face[Axis, Side, Orientation](start={<font color="red">fill</font>({phi_IC[<font color="red">cartWrap</font>(
        axis + orientation)] <font color="blue">for </font>orientation<font color="blue"> in </font>Orientation}, 2) <font color="blue">for </font>axis<font color="blue"> in </font>
        Axis}) <font color="darkgreen">&quot;Shear forces on the faces&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureAbsolute">Q.TemperatureAbsolute</a> T_face[Axis, Side](<font color="blue">each </font>start=T_IC) <font color="darkgreen">
    &quot;Temperatures at the faces&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> Qdot_face[Axis, Side] <font color="darkgreen">&quot;Heat flow rates into the faces&quot;</font>;

<textblock type="annotcomp" expanded="false">  <font color="blue">outer </font><a href="FCSys_BCs.html#FCSys.BCs.Environment">FCSys.BCs.Environment</a> environment <font color="darkgreen">&quot;Environmental settings&quot;</font>;</textblock>
  <font color="darkgreen">// Note:  In Dymola 7.4 it&#39;s necessary to add the missing inner message</font>
  <font color="darkgreen">// here to give a warning message, even though it&#39;s included in the</font>
  <font color="darkgreen">// Environment model too.</font>

<font color="blue">initial </font><font color="blue">equation </font>
  <font color="darkgreen">// Check that the initialization methods are valid.</font>
  <font color="red">assert</font>(initMethPartNum &lt;&gt; initMethTemp<font color="blue"> or </font>initMethPartNum == InitMethScalar.None,
    &quot;The initialization methods for particle number and temperature cannot be the same (unless None).&quot;);
  <font color="red">assert</font>(<font color="blue">not </font>(overrideEOS<font color="blue"> and </font>(initMethPartNum == InitMethScalar.AmountVolumic<font color="blue">
     or </font>initMethTemp == InitMethScalar.AmountVolumic)), &quot;Volumic amount cannot be used as an initial or fixed condition since it is used to override the equation of state (overrideEOS = true).&quot;);
  <font color="blue">if </font><font color="blue">not </font>Data.isCompressible<font color="blue"> then</font>
    <font color="red">assert</font>(initMethPartNum &lt;&gt; InitMethScalar.Pressure<font color="blue"> and </font>initMethPartNum &lt;&gt;
      InitMethScalar.PressureRate<font color="blue"> or </font>setPartNum, &quot;The material is incompressible,
      yet the initialization method for particle number involves pressure.&quot;);
    <font color="red">assert</font>(initMethTemp &lt;&gt; InitMethScalar.Pressure<font color="blue"> and </font>initMethTemp &lt;&gt;
      InitMethScalar.PressureRate<font color="blue"> or </font>setTemp, &quot;The material is incompressible,
      yet the initialization method for temperature involves pressure.&quot;);
    <font color="blue">if </font><font color="blue">not </font>Data.hasThermalExpansion<font color="blue"> then</font>
      <font color="red">assert</font>(initMethPartNum &lt;&gt; InitMethScalar.AmountVolumic<font color="blue"> and </font>
        initMethPartNum &lt;&gt; InitMethScalar.AmountVolumicRate<font color="blue"> or </font>setPartNum, &quot;The material has constant density,
      yet the initialization method for particle number involves density.&quot;);
      <font color="red">assert</font>(initMethTemp &lt;&gt; InitMethScalar.AmountVolumic<font color="blue"> and </font>initMethTemp &lt;&gt;
        InitMethScalar.AmountVolumicRate<font color="blue"> or </font>setPartNum, &quot;The material has constant density,
      yet the initialization method for temperature involves density.&quot;);
    <font color="blue">end if</font>;
  <font color="blue">end if</font>;

  <font color="darkgreen">/* This is commented out because it may be annoying.
  // Warn when index reduction may be necessary.
  if abs(Xi) &lt; Modelica.Constants.small then
    Modelica.Utilities.Streams.print(&quot;Warning: The fusivity is zero.
    This may directly couple the densities within neighboring subregions.\nConsider setting the value of Xi as final (if not already) so that index reduction may be performed.&quot;);
  end if;
  if abs(F) &gt; Modelica.Constants.small then
    Modelica.Utilities.Streams.print(&quot;Warning: The fluidity is zero.
    This may directly couple the velocity of this species with others within the subregion or with the same species within neighboring subregions.\nConsider setting the value of F as final (if not already) so that index reduction may be performed.&quot;);
  end if;
  if abs(R) &gt; Modelica.Constants.small then
    Modelica.Utilities.Streams.print(&quot;Warning: The thermal resistance is zero.
    This may directly couple the temperature of this species with others within the subregion or with the same species within neighboring subregions.\nConsider setting the value of R as final (if not already) so that index reduction may be performed.&quot;);
  end if;
  // Note:  According to the Modelica &gt;=3.0 specification, these
  // checks should be possible using the assert() command with
  // level=AssertionLevel.warning.  However, this isn&#39;t supported in
  // Dymola 7.4 or FD2012.
  */</font>

  <font color="darkgreen">// Particle number</font>
  <font color="blue">if </font>setPartNum<font color="blue"> then</font>
    <font color="darkgreen">// Ensure that a condition is selected, since the state is prescribed.</font>
    <font color="red">assert</font>(initMethPartNum &lt;&gt; InitMethScalar.None, &quot;The state for particle number is prescribed,
    yet its condition is not defined.\nChoose a condition besides None.&quot;);
  <font color="blue">elseif </font><font color="blue">not </font>overrideEOS<font color="blue"> or </font>rho_IC &gt; 0<font color="blue"> then</font>
    <font color="darkgreen">// Initialize since there&#39;s a time-varying state.</font>
    <font color="blue">if </font>initMethPartNum == InitMethScalar.Amount<font color="blue"> then</font>
      N = N_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.AmountRate<font color="blue"> then</font>
      <font color="red">der</font>(N)/U.s = derN_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.AmountVolumic<font color="blue"> then</font>
      rho = rho_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.AmountVolumicRate<font color="blue"> then</font>
      <font color="red">der</font>(rho)/U.s = derrho_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.Volume<font color="blue"> then</font>
      V = V_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.VolumeRate<font color="blue"> then</font>
      <font color="red">der</font>(V)/U.s = derV_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.Pressure<font color="blue"> then</font>
      p = p_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.PressureRate<font color="blue"> then</font>
      <font color="red">der</font>(p)/U.s = derp_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.Temperature<font color="blue"> then</font>
      T = T_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.TemperatureRate<font color="blue"> then</font>
      <font color="red">der</font>(T)/U.s = derT_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.SpecificEntropy<font color="blue"> then</font>
      s = s_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.SpecificEntropyRate<font color="blue"> then</font>
      <font color="red">der</font>(s)/U.s = ders_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.SpecificEnthalpy<font color="blue"> then</font>
      h = h_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.SpecificEnthalpyRate<font color="blue"> then</font>
      <font color="red">der</font>(h)/U.s = derh_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.PotentialElectrochemical<font color="blue"> then</font>
      mu = mu_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.PotentialElectrochemicalRate<font color="blue"> then</font>
      <font color="red">der</font>(mu)/U.s = dermu_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.ReactionRate<font color="blue"> then</font>
      chemical.Ndot = Ndot_IC;
      <font color="darkgreen">// Else, initMethPartNum == InitMethScalar.None; then, there are no</font>
      <font color="darkgreen">// initial equations.</font>
    <font color="blue">end if</font>;
  <font color="blue">end if</font>;

  <font color="darkgreen">// Velocity</font>
  <font color="blue">for </font>axis<font color="blue"> in </font>Axis<font color="blue"> loop</font>
    <font color="blue">if </font>inclLin[axis]<font color="blue"> then</font>
      <font color="blue">if </font>setVel[axis]<font color="blue"> then</font>
        <font color="darkgreen">// Ensure that a condition is selected, since the state is</font>
        <font color="darkgreen">// prescribed.</font>
        <font color="red">assert</font>(initMethVel[axis] &lt;&gt; InitMethVelocity.None, &quot;The state for the &quot; +
          {&quot;x&quot;,&quot;y&quot;,&quot;z&quot;}[axis] + &quot;-axis component of linear momentum is prescribed,
        yet its condition is not defined.\nChoose any condition besides None.&quot;);
      <font color="blue">elseif </font><font color="blue">not </font>overrideEOS<font color="blue"> or </font>rho_IC &gt; 0<font color="blue"> then</font>
        <font color="darkgreen">// Initialize since there&#39;s a time-varying state.</font>
        <font color="blue">if </font>initMethVel[axis] == InitMethVelocity.Velocity<font color="blue"> then</font>
          phi[linAxes[axis]] = phi_IC[axis];
        <font color="blue">elseif </font>initMethVel[axis] == InitMethVelocity.Acceleration<font color="blue"> then</font>
          <font color="red">der</font>(phi[linAxes[axis]])/U.s = derphi_IC[axis];
        <font color="blue">elseif </font>initMethX == InitMethVelocity.Current<font color="blue"> then</font>
          I[linAxes[axis]] = I_IC[axis];
        <font color="blue">elseif </font>initMethVel[axis] == InitMethVelocity.CurrentRate<font color="blue"> then</font>
          <font color="red">der</font>(I[linAxes[axis]])/U.s = derI_IC[axis];
          <font color="darkgreen">// Else, initMethVel[axis] == InitMethVelocity.None; then, there are</font>
          <font color="darkgreen">// no initial equations.</font>
        <font color="blue">end if</font>;
      <font color="blue">end if</font>;
    <font color="blue">end if</font>;
  <font color="blue">end for</font>;

  <font color="darkgreen">// Temperature</font>
  <font color="blue">if </font>setTemp<font color="blue"> then</font>
    <font color="darkgreen">// Ensure that a condition is selected, since the state is prescribed.</font>
    <font color="red">assert</font>(initMethTemp &lt;&gt; InitMethScalar.None, &quot;The state for temperature is prescribed,
    yet its condition is not defined.\nChoose a condition besides None.&quot;);
  <font color="blue">elseif </font><font color="blue">not </font>overrideEOS<font color="blue"> or </font>rho_IC &gt; 0<font color="blue"> then</font>
    <font color="darkgreen">// Initialize since there&#39;s a time-varying state.</font>
    <font color="blue">if </font>initMethTemp == InitMethScalar.Amount<font color="blue"> then</font>
      N = N_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.AmountRate<font color="blue"> then</font>
      <font color="red">der</font>(N)/U.s = derN_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.AmountVolumic<font color="blue"> then</font>
      rho = rho_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.AmountVolumicRate<font color="blue"> then</font>
      <font color="red">der</font>(rho)/U.s = derrho_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.Volume<font color="blue"> then</font>
      V = V_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.VolumeRate<font color="blue"> then</font>
      <font color="red">der</font>(V)/U.s = derV_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.Pressure<font color="blue"> then</font>
      p = p_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.PressureRate<font color="blue"> then</font>
      <font color="red">der</font>(p)/U.s = derp_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.Temperature<font color="blue"> then</font>
      T = T_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.TemperatureRate<font color="blue"> then</font>
      <font color="red">der</font>(T)/U.s = derT_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.SpecificEntropy<font color="blue"> then</font>
      s = s_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.SpecificEntropyRate<font color="blue"> then</font>
      <font color="red">der</font>(s)/U.s = ders_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.SpecificEnthalpy<font color="blue"> then</font>
      h = h_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.SpecificEnthalpyRate<font color="blue"> then</font>
      <font color="red">der</font>(h)/U.s = derh_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.PotentialElectrochemical<font color="blue"> then</font>
      mu = mu_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.PotentialElectrochemicalRate<font color="blue"> then</font>
      <font color="red">der</font>(mu)/U.s = dermu_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.ReactionRate<font color="blue"> then</font>
      chemical.Ndot = Ndot_IC;
      <font color="darkgreen">// Else, initMethTemp == InitMethScalar.None; then, there are no</font>
      <font color="darkgreen">// initial equations.</font>
    <font color="blue">end if</font>;
  <font color="blue">end if</font>;

<font color="blue">equation </font>
  <font color="darkgreen">// Aliases (only for clarity)</font>
  p = inert.p;
  V = inert.V;
  rho*V = N;
  T = common.thermal.T;
  phi = common.mechanical.phi;
  mu = T*chemical.muPerT;
  h = mu + T*s;
  N*phi = L[cartAxes] .* I;
  M = Data.m*N;
  p_face = {<font color="red">Data.p_Tv</font>(T_face[axis, :], {1,1} ./ rho_face[axis, :]) <font color="blue">for </font>axis<font color="blue"> in </font>
    Axis};
  c_V = <font color="red">Data.c_V</font>(T, p);

  <font color="darkgreen">// Thermodynamic correlations</font>
  <font color="blue">if </font>overrideEOS<font color="blue"> then</font>
    N = rho_IC*V;
  <font color="blue">elseif </font>Data.isCompressible<font color="blue"> then</font>
    p = <font color="red">Data.p_Tv</font>(T, V/N);
  <font color="blue">else</font>
    V = N*<font color="red">Data.v_Tp</font>(T, p);
  <font color="blue">end if</font>;
  h = <font color="red">Data.h</font>(T, p);
  s = <font color="red">Data.s</font>(T, p);

  <font color="darkgreen">// Exchange</font>
  <font color="darkgreen">// --------</font>
  <font color="darkgreen">// Material</font>
  chemical.mPhidot = <font color="red">semiLinear</font>(
    Data.m*chemical.Ndot,
    chemical.phi,
    phi) <font color="darkgreen">&quot;Advection&quot;</font>;
  F*inert.mPhidot = 2*Lstar*(inert.phi - phi) <font color="darkgreen">&quot;Diffusion&quot;</font>;
  <font color="darkgreen">//</font>
  <font color="darkgreen">// Fluid/thermal</font>
  chemical.Hdot = <font color="red">semiLinear</font>(
    chemical.Ndot,
    chemical.hbar*Data.m,
    h) <font color="darkgreen">&quot;Advection&quot;</font>;
  R*inert.Qdot = 2*Lstar*(inert.T - T) <font color="darkgreen">&quot;Diffusion&quot;</font>;

  <font color="darkgreen">// Transport</font>
  <font color="blue">for </font>axis<font color="blue"> in </font>Axis<font color="blue"> loop</font>
    <font color="blue">for </font>side<font color="blue"> in </font>Side<font color="blue"> loop</font>
      <font color="darkgreen">// Material</font>
      Xi*(Ndot_face[axis, side] - (<font color="blue">if </font>inclLin[axis]<font color="blue"> then </font><font color="red">inSign</font>(side)*I[linAxes[
        axis]]<font color="blue"> else </font>0)) = Lstar_trans[axis]*(rho_face[axis, side] - rho)*(<font color="blue">if </font>
        upstream[axis]<font color="blue"> and </font>inclLin[axis]<font color="blue"> then </font>(<font color="red">exp</font>(<font color="red">inSign</font>(side)*I[linAxes[axis]]
        *alpha_Xi/(2*Lstar_trans[axis])) + 1)<font color="blue"> else </font>2);
      <font color="blue">if </font>[xNegative.thermoOpt, xPositive.thermoOpt; yNegative.thermoOpt,
          yPositive.thermoOpt; zNegative.thermoOpt, zPositive.thermoOpt][axis,
          side] &lt;&gt; ThermoOpt.OpenDiabatic<font color="blue"> then</font>
        Ndot_face[axis, side] = 0 <font color="darkgreen">&quot;Closed BC&quot;</font>;
      <font color="blue">end if</font>;

      <font color="darkgreen">// Mechanical</font>
      <font color="blue">for </font>orientation<font color="blue"> in </font>Orientation<font color="blue"> loop</font>
        F*mPhidot_face[axis, side, orientation] = 4*Lstar_trans[axis]*(phi_face[
          axis, side, orientation] - (<font color="blue">if </font>inclLin[<font color="red">cartWrap</font>(axis + orientation)]<font color="blue">
           then </font>phi[linAxes[<font color="red">cartWrap</font>(axis + orientation)]]<font color="blue"> else </font>0))*(<font color="blue">if </font>
          upstream[axis]<font color="blue"> and </font>inclLin[axis]<font color="blue"> then </font>(<font color="red">exp</font>(<font color="red">inSign</font>(side)*I[linAxes[
          axis]]*alpha_F/(2*Lstar_trans[axis])) + 1)<font color="blue"> else </font>2);
        <font color="blue">if </font>{{{xNegative.inviscidY,xNegative.inviscidZ},{xPositive.inviscidY,
            xPositive.inviscidZ}},{{yNegative.inviscidZ,yNegative.inviscidX},{
            yPositive.inviscidZ,yPositive.inviscidX}},{{zNegative.inviscidX,
            zNegative.inviscidY},{zPositive.inviscidX,zPositive.inviscidY}}}[
            axis, side, orientation]<font color="blue"> then</font>
          mPhidot_face[axis, side, orientation] = 0 <font color="darkgreen">&quot;Inviscid BC&quot;</font>;
        <font color="blue">end if</font>;
      <font color="blue">end for</font>;

      <font color="darkgreen">// Thermal</font>
      R*Qdot_face[axis, side] = Lstar_trans[axis]*(T_face[axis, side] - T)*(<font color="blue">if </font>
        upstream[axis]<font color="blue"> and </font>inclLin[axis]<font color="blue"> then </font>(<font color="red">exp</font>(<font color="red">inSign</font>(side)*I[linAxes[axis]]
        *alpha_R/(2*Lstar_trans[axis])) + 1)<font color="blue"> else </font>2);
      <font color="blue">if </font>[xNegative.thermoOpt, xPositive.thermoOpt; yNegative.thermoOpt,
          yPositive.thermoOpt; zNegative.thermoOpt, zPositive.thermoOpt][axis,
          side] == ThermoOpt.ClosedAdiabatic<font color="blue"> then</font>
        Qdot_face[axis, side] = 0 <font color="darkgreen">&quot;Adiabatic BC&quot;</font>;
      <font color="blue">end if</font>;
    <font color="blue">end for</font>;
  <font color="blue">end for</font>;

  <font color="darkgreen">// Material dynamics</font>
  <font color="blue">if </font>setPartNum<font color="blue"> then</font>
    <font color="darkgreen">// Apply the IC for all time (material not conserved).</font>
    <font color="blue">if </font>initMethPartNum == InitMethScalar.Amount<font color="blue"> then</font>
      N = N_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.AmountRate<font color="blue"> then</font>
      <font color="red">der</font>(N)/U.s = derN_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.AmountVolumic<font color="blue"> then</font>
      rho = rho_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.AmountVolumicRate<font color="blue"> then</font>
      <font color="red">der</font>(rho)/U.s = derrho_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.Volume<font color="blue"> then</font>
      V = V_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.VolumeRate<font color="blue"> then</font>
      <font color="red">der</font>(V)/U.s = derV_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.Pressure<font color="blue"> then</font>
      p = p_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.PressureRate<font color="blue"> then</font>
      <font color="red">der</font>(p)/U.s = derp_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.Temperature<font color="blue"> then</font>
      T = T_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.TemperatureRate<font color="blue"> then</font>
      <font color="red">der</font>(T)/U.s = derT_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.SpecificEntropy<font color="blue"> then</font>
      s = s_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.SpecificEntropyRate<font color="blue"> then</font>
      <font color="red">der</font>(s)/U.s = ders_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.SpecificEnthalpy<font color="blue"> then</font>
      h = h_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.SpecificEnthalpyRate<font color="blue"> then</font>
      <font color="red">der</font>(h)/U.s = derh_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.PotentialElectrochemical<font color="blue"> then</font>
      mu = mu_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.PotentialElectrochemicalRate<font color="blue"> then</font>
      <font color="red">der</font>(mu)/U.s = dermu_IC;
    <font color="blue">else</font>
      <font color="darkgreen">//if initMethPartNum == InitMethScalar.ReactionRate then</font>
      chemical.Ndot = Ndot_IC;
      <font color="darkgreen">// Note:  initMethPartNum == InitMethScalar.None can&#39;t occur due to an</font>
      <font color="darkgreen">// assertion.</font>
    <font color="blue">end if</font>;
  <font color="blue">else</font>
    <font color="red">der</font>(N)/U.s = chemical.Ndot + <font color="red">sum</font>(Ndot_face) <font color="darkgreen">&quot;Material conservation&quot;</font>;
  <font color="blue">end if</font>;

  <font color="darkgreen">// Mechanical dynamics</font>
  <font color="blue">for </font>axis<font color="blue"> in </font>1:n_lin<font color="blue"> loop</font>
    <font color="blue">if </font>setVel[cartAxes[axis]]<font color="blue"> then</font>
      <font color="darkgreen">// Apply the IC for all time (linear momentum isn&#39;t conserved along</font>
      <font color="darkgreen">// this axis).</font>
      <font color="blue">if </font>initMethVel[cartAxes[axis]] == InitMethVelocity.Velocity<font color="blue"> then</font>
        phi[axis] = phi_IC[cartAxes[axis]];
      <font color="blue">elseif </font>initMethVel[cartAxes[axis]] == InitMethVelocity.Acceleration<font color="blue"> then</font>
        <font color="red">der</font>(phi[axis])/U.s = derphi_IC[cartAxes[axis]];
      <font color="blue">elseif </font>initMethX == InitMethVelocity.Current<font color="blue"> then</font>
        I[axis] = I_IC[cartAxes[axis]];
      <font color="blue">elseif </font>initMethVel[cartAxes[axis]] == InitMethVelocity.CurrentRate<font color="blue"> then</font>
        <font color="red">der</font>(I[axis])/U.s = derI_IC[cartAxes[axis]];
        <font color="darkgreen">// Note:  initMethVel[cartAxes[axis]] == InitMethVelocity.None can&#39;t</font>
        <font color="darkgreen">// occur due to an assertion.</font>
      <font color="blue">end if</font>;
    <font color="blue">else</font>
      <font color="red">der</font>(M*phi[axis])/U.s = chemical.mPhidot[axis] + common.mechanical.mPhidot[
        axis] + inert.mPhidot[axis] + A[cartAxes[axis]]*<font color="red">Delta</font>(p_face[cartAxes[
        axis], :]) + Data.m*<font color="red">Delta</font>(<font color="red">Data.v_Tp</font>(T_face[cartAxes[axis], :], p_face[
        cartAxes[axis], :]) .* Ndot_face[cartAxes[axis], :] .^ 2)/A[cartAxes[
        axis]] + <font color="red">sum</font>(Data.m*<font color="red">Sigma</font>(phi_face[<font color="red">cartWrap</font>(cartAxes[axis] -
        orientation), :, orientation] .* Ndot_face[<font color="red">cartWrap</font>(cartAxes[axis] -
        orientation), :]) + <font color="red">Sigma</font>(mPhidot_face[<font color="red">cartWrap</font>(cartAxes[axis] -
        orientation), :, orientation]) <font color="blue">for </font>orientation<font color="blue"> in </font>Orientation) + M*
        environment.a[cartAxes[axis]] <font color="darkgreen">&quot;Conservation of linear momentum&quot;</font>;
    <font color="blue">end if</font>;
  <font color="blue">end for</font>;

  <font color="darkgreen">// Thermal dynamics</font>
  <font color="blue">if </font>setTemp<font color="blue"> then</font>
    <font color="darkgreen">// Apply the IC for all time (energy not conserved).</font>
    <font color="blue">if </font>initMethTemp == InitMethScalar.Amount<font color="blue"> then</font>
      N = N_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.AmountRate<font color="blue"> then</font>
      <font color="red">der</font>(N)/U.s = derN_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.AmountVolumic<font color="blue"> then</font>
      rho = rho_IC;
    <font color="blue">elseif </font>initMethPartNum == InitMethScalar.AmountVolumicRate<font color="blue"> then</font>
      <font color="red">der</font>(rho)/U.s = derrho_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.Volume<font color="blue"> then</font>
      V = V_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.VolumeRate<font color="blue"> then</font>
      <font color="red">der</font>(V)/U.s = derV_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.Pressure<font color="blue"> then</font>
      p = p_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.PressureRate<font color="blue"> then</font>
      <font color="red">der</font>(p)/U.s = derp_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.Temperature<font color="blue"> then</font>
      T = T_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.TemperatureRate<font color="blue"> then</font>
      <font color="red">der</font>(T)/U.s = derT_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.SpecificEntropy<font color="blue"> then</font>
      s = s_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.SpecificEntropyRate<font color="blue"> then</font>
      <font color="red">der</font>(s)/U.s = ders_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.SpecificEnthalpy<font color="blue"> then</font>
      h = h_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.SpecificEnthalpyRate<font color="blue"> then</font>
      <font color="red">der</font>(h)/U.s = derh_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.PotentialElectrochemical<font color="blue"> then</font>
      mu = mu_IC;
    <font color="blue">elseif </font>initMethTemp == InitMethScalar.PotentialElectrochemicalRate<font color="blue"> then</font>
      <font color="red">der</font>(mu)/U.s = dermu_IC;
    <font color="blue">else</font>
      <font color="darkgreen">//if initMethTemp == InitMethScalar.ReactionRate then</font>
      chemical.Ndot = Ndot_IC;
      <font color="darkgreen">// Note:  initMethTemp == InitMethScalar.None can&#39;t occur due to an</font>
      <font color="darkgreen">// assertion.</font>
    <font color="blue">end if</font>;
  <font color="blue">else</font>
    (<font color="red">der</font>(N*h) + <font color="red">der</font>(M*phi*phi)/2 - V*<font color="red">der</font>(p))/U.s = chemical.phi*chemical.mPhidot
      /2 + Data.m*chemical.hbar*chemical.Ndot + phi*common.mechanical.mPhidot +
      common.thermal.Qdot + inert.phi*inert.mPhidot + inert.Qdot + <font color="red">sum</font>(<font color="red">sum</font>((<font color="red">
      Data.h</font>(T_face[axis, side], p_face[axis, side]) + Data.m*((<font color="red">Data.v_Tp</font>(
      T_face[axis, side], p_face[axis, side])*Ndot_face[axis, side]/A[axis])^2 +
      phi_face[axis, side, :]*phi_face[axis, side, :])/2)*Ndot_face[axis, side]
      <font color="blue">for </font>side<font color="blue"> in </font>Side) <font color="blue">for </font>axis<font color="blue"> in </font>Axis) + <font color="red">sum</font>(phi_face .* mPhidot_face) + <font color="red">sum</font>
      (Qdot_face) <font color="darkgreen">&quot;Energy conservation&quot;</font>;
  <font color="blue">end if</font>;
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>Species;
</pre>
      </div>
    </div>
  </div>
</div>
<div class="footer">
  &copy; Copyright 2012, Kevin Davies, Georgia Tech Research Corporation. Last updated Sun Jan 13 12:30:14 2013.
</div>
</body>
</html>
