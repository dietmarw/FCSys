<html>
<head>
<title>FCSys.Subregions.Species</title>
<meta name="title" content="Modelica fuel cell library">
<meta name="keywords" content="fuel cell library, FCSys, fuel cell, PEM, proton exchange membrane, polymer exchange membrane, PEMFC, Modelica, Dymola, open-source, electrochemistry">
<meta name="date" content="2013-7-2">
<meta name="description" content="Models for single-species, single-phase storage, transport, and exchange of material, translational momentum, and energy">
<link rel="stylesheet" type="text/css" charset="utf-8" media="all" href="stylesheets/ModelicaDoc.css">
<link rel="shortcut icon" href="images/favicon.ico">
<script type="text/javascript" src="javascripts/analytics.js"></script>
</head>
<body>
<div class="sidebar">
  <div class="sidebarwrapper">
  <a href="index.html"><p class="sidebar-title">FCSys</p></a>
  <p class="logo"><a href="index.html">
    <img src="images/icon.gif" class="logo" alt="Logo" width=150>
  </a></p>

<h3>Table of Contents</h3>

    <ul>
    <li><a href="FCSys_UsersGuide.html">User's Guide</a></li>
    <li><a href="FCSys_Blocks.html">Blocks</a></li>
    <li><a href="FCSys_Conditions.html">Conditions</a></li>
    <li><a href="FCSys_Assemblies.html">Assemblies</a></li>
    <li><a href="FCSys_Regions.html">Regions</a></li>
    <li><a href="FCSys_Subregions.html">Subregions</a></li>
    <li><a href="FCSys_Connectors.html">Connectors</a></li>
    <li><a href="FCSys_Characteristics.html">Characteristics</a></li>
    <li><a href="FCSys_Units.html">Units</a></li>
    <li><a href="FCSys_Quantities.html">Quantities</a></li>
    <li><a href="FCSys_BaseClasses.html">BaseClasses</a></li>
    </ul>

  <h3>Download</h3>
    <ul>
      <li><a href="https://github.com/kdavies4/FCSys/zipball/release" rel="nofollow">Latest version</a> (**Empty; please check back soon or contact kdavies4 at gmail.com.)</li>
    </ul>
  </div>
</div>

<div class="document">
  <div class="documentwrapper">
    <div class="bodywrapper">
      <div class="body">

<h2><a name="FCSys.Subregions.Species"></a><a href="FCSys_Subregions.html#FCSys.Subregions">FCSys.Subregions</a>.Species</h2>

<b>Models for single-species, single-phase storage, transport, and exchange of material, translational momentum, and energy</b>

<h3>Information</h3>

Extends from <a href="http://build.openmodelica.org/Documentation/Modelica.Icons.Package.html#Modelica.Icons.Package">Modelica.Icons.Package</a> (Icon for standard packages).

<h3>Package Content</h3>

<table border=1 cellspacing=0 cellpadding=2 >
<tr><th>Name</th><th>Description</th></tr>
<tr><td><img src="images/FCSys.Subregions.Species.'C+'S.png" alt="FCSys.Subregions.Species.'C+'" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species_'C+'.html#FCSys.Subregions.Species.'C+'">'C+'</a>
</td><td>C</td></tr>
<tr><td><img src="images/FCSys.Subregions.Species.'C+'S.png" alt="FCSys.Subregions.Species.'C19HF37O5S-'" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species_'C19HF37O5S-'.html#FCSys.Subregions.Species.'C19HF37O5S-'">'C19HF37O5S-'</a>
</td><td>C<sub>19</sub>HF<sub>37</sub>O<sub>5</sub>S<sup>-</sup></td></tr>
<tr><td><img src="images/FCSys.Subregions.Species.'C+'S.png" alt="FCSys.Subregions.Species.'e-'" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species_'e-'.html#FCSys.Subregions.Species.'e-'">'e-'</a>
</td><td>e<sup>-</sup></td></tr>
<tr><td><img src="images/FCSys.Subregions.Species.'C+'S.png" alt="FCSys.Subregions.Species.'H+'" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species_'H+'.html#FCSys.Subregions.Species.'H+'">'H+'</a>
</td><td>H<sup>+</sup></td></tr>
<tr><td><img src="images/FCSys.Subregions.Species.'C+'S.png" alt="FCSys.Subregions.Species.H2" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species_H2.html#FCSys.Subregions.Species.H2">H2</a>
</td><td>H<sub>2</sub></td></tr>
<tr><td><img src="images/FCSys.Subregions.Species.'C+'S.png" alt="FCSys.Subregions.Species.H2O" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species_H2O.html#FCSys.Subregions.Species.H2O">H2O</a>
</td><td>H<sub>2</sub>O</td></tr>
<tr><td><img src="images/FCSys.Subregions.Species.'C+'S.png" alt="FCSys.Subregions.Species.N2" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species_N2.html#FCSys.Subregions.Species.N2">N2</a>
</td><td>N<sub>2</sub></td></tr>
<tr><td><img src="images/FCSys.Subregions.Species.'C+'S.png" alt="FCSys.Subregions.Species.O2" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species_O2.html#FCSys.Subregions.Species.O2">O2</a>
</td><td>O<sub>2</sub></td></tr>
<tr><td><img src="images/FCSys.Subregions.Species.SpeciesSolidS.png" alt="FCSys.Subregions.Species.SpeciesSolid" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.SpeciesSolid">SpeciesSolid</a>
</td><td><a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.Species">Species</a> model for a solid (inert and zero velocity)</td></tr>
<tr><td><img src="images/FCSys.Subregions.Species.SpeciesSolidS.png" alt="FCSys.Subregions.Species.SpeciesIsochoric" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.SpeciesIsochoric">SpeciesIsochoric</a>
</td><td><a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.Species">Species</a> model for an isochoric material</td></tr>
<tr><td><img src="images/FCSys.Subregions.Species.SpeciesSolidS.png" alt="FCSys.Subregions.Species.Species" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.Species">Species</a>
</td><td>Model to exchange, transport, and store the material, momentum, and energy of one species</td></tr>
<tr><td><img src="images/FCSys.Subregions.Species.BaseClassesS.png" alt="FCSys.Subregions.Species.BaseClasses" width=20  height=20 align=top>&nbsp;<a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses">BaseClasses</a>
</td><td>Base classes (generally not for direct use)</td></tr>
</table>
<hr>

<h2><img src="images/FCSys.Subregions.Species.SpeciesSolidI.png" alt="FCSys.Subregions.Species.SpeciesSolid" align=RIGHT border=1 width=80  height=80 >
<a name="FCSys.Subregions.Species.SpeciesSolid"></a><a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species">FCSys.Subregions.Species</a>.SpeciesSolid</h2>
<b><a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.Species">Species</a> model for a solid (inert and zero velocity)</b><p>
<img src="images/FCSys.Subregions.Species.SpeciesSolidD.png" alt="FCSys.Subregions.Species.SpeciesSolid">

<h3>Information</h3>

<p>Assumptions:<ol>
  <li>Zero dynamic compressibility (&rArr; uniform velocity in the axial direction)</li>
  <li>Zero fluidity (&rArr; no shearing)</li></ol></p>

  <p>For more information, see the <a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.Species">Species</a> model.</p><p>
Extends from <a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.SpeciesIsochoric">SpeciesIsochoric</a> (<a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.Species">Species</a> model for an isochoric material).
<p>
<h3>Parameters</h3>
<p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Type</th><th>Name</th><th>Default</th><th>Description</th></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Geometry</td></tr>
<tr><td>Integer</td><td>n_faces</td><td>1</td><td>Number of pairs of faces (<i>n</i><sub>faces</sub>)</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Material properties</td></tr>
<tr><TD colspan="2">replaceable package Data</td><td>Characteristics.BaseClasses&hellip;.</td><td>Characteristic data</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TimeAbsolute">TimeAbsolute</a></td><td>tauprime</td><td>0</td><td>Phase change interval (&tau;&prime;) [T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Mobility">Mobility</a></td><td>mu</td><td>Data.mu(T, v)</td><td>Mobility (&mu;) [N.T/m]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TimeAbsolute">TimeAbsolute</a></td><td>nu</td><td>Data.nu(T, v)</td><td>Thermal independity (&nu;) [T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Fluidity">Fluidity</a></td><td>beta</td><td>1</td><td>Dynamic compressibility (&beta;) [l.T/m]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Fluidity">Fluidity</a></td><td>zeta</td><td>1</td><td>Fluidity (&zeta;) [l.T/m]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.ResistivityThermal">ResistivityThermal</a></td><td>theta</td><td>Data.theta(T, v)</td><td>Thermal resistivity (&theta;) [l.T/N]</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=4><b>Assumptions</b></td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Axes with upstream discretization</td></tr>
<tr><td>Boolean</td><td>upstreamX</td><td>false</td><td>X</td></tr>
<tr><td>Boolean</td><td>upstreamY</td><td>false</td><td>Y</td></tr>
<tr><td>Boolean</td><td>upstreamZ</td><td>false</td><td>Z</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Formulation of conservation equations</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.Conservation">Conservation</a></td><td>consMaterial</td><td>Conservation.IC</td><td>Material</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.Conservation">Conservation</a></td><td>consTransX</td><td>Conservation.IC</td><td>X-axis translational momentum</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.Conservation">Conservation</a></td><td>consTransY</td><td>Conservation.IC</td><td>Y-axis translational momentum</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.Conservation">Conservation</a></td><td>consTransZ</td><td>Conservation.IC</td><td>Z-axis translational momentum</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.Conservation">Conservation</a></td><td>consEnergy</td><td>Conservation.Dynamic</td><td>Energy</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Flow conditions</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">NumberAbsolute</a></td><td>Nu_Phi[Axis]</td><td>{4,4,4}</td><td>Translational Nusselt numbers (<b><i>Nu</i><sub>&Phi;</sub></b>) [1]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">NumberAbsolute</a></td><td>Nu_Q</td><td>1</td><td>Thermal Nusselt number (<i>Nu</i><sub><i>Q</i></sub>) [1]</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=4><b>Initialization</b></td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Material and energy</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitScalar">InitScalar</a></td><td>initMaterial</td><td>InitScalar.Volume</td><td>Method of initializing the material state</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitScalar">InitScalar</a></td><td>initEnergy</td><td>InitScalar.Temperature</td><td>Method of initializing the thermal state</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Amount">Amount</a></td><td>N_IC</td><td>&nbsp;</td><td>Initial particle number (<i>N</i><sub>IC</sub>) [N]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Density">Density</a></td><td>rho_IC</td><td>&nbsp;</td><td>Initial density (&rho;<sub>IC</sub>) [N/l3]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Volume">Volume</a></td><td>V_IC</td><td>&nbsp;</td><td>Initial volume (<i>V</i><sub>IC</sub>) [l3]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PressureAbsolute">PressureAbsolute</a></td><td>p_IC</td><td>&nbsp;</td><td>Initial pressure (<i>p</i><sub>IC</sub>) [m/(l.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureAbsolute">TemperatureAbsolute</a></td><td>T_IC</td><td>&nbsp;</td><td>Initial temperature (<i>T</i><sub>IC</sub>) [l2.m/(N.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Potential</a></td><td>h_IC</td><td>&nbsp;</td><td>Initial specific enthalpy (<i>h</i><sub>IC</sub>) [l2.m/(N.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Potential</a></td><td>g_IC</td><td>&nbsp;</td><td>Initial Gibbs potential (<i>g</i><sub>IC</sub>) [l2.m/(N.T2)]</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Translational momentum</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitTranslational">InitTranslational</a></td><td>initTransX</td><td>InitTranslational.Velocity</td><td>Method of initializing the x-axis state</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitTranslational">InitTranslational</a></td><td>initTransY</td><td>InitTranslational.Velocity</td><td>Method of initializing the y-axis state</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitTranslational">InitTranslational</a></td><td>initTransZ</td><td>InitTranslational.Velocity</td><td>Method of initializing the z-axis state</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Velocity">Velocity</a></td><td>phi_IC[Axis]</td><td>zeros(3)</td><td>Initial velocity (<b>&phi;</b><sub>IC</sub>) [l/T]</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=4><b>Advanced</b></td></tr>
<tr><td>Boolean</td><td>invertEOS</td><td>false</td><td>Invert the equation of state</td></tr>
</table>
<p>
<h3>Connectors</h3>
<p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Type</th><th>Name</th><th>Description</th></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Chemical">Chemical</a></td><td>chemical</td><td>Connector for reactions</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Physical">Physical</a></td><td>physical</td><td>Connector for phase change</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Inert">Inert</a></td><td>inert</td><td>Connector to directly couple velocity or temperature with other species</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.InertDalton">InertDalton</a></td><td>inertDalton</td><td>Connector for translational and thermal diffusive exchange, with additivity of pressure</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Face">Face</a></td><td>faces[n_faces, Side]</td><td>Connectors to transport material, translational momentum, and thermal energy through the boundaries</td></tr>
</table>
<p>
<h3>Modelica definition</h3>

<pre>
<font color="blue">model</font> SpeciesSolid <font color="darkgreen">
  &quot;<a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.Species">Species</a> model for a solid (inert and zero velocity)&quot;</font>
  <font color="blue">extends </font><a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.SpeciesIsochoric">SpeciesIsochoric</a>(
    <font color="blue">final </font>upstreamX=false,
    <font color="blue">final </font>upstreamY=false,
    <font color="blue">final </font>upstreamZ=false,
    <font color="blue">final </font>phi_IC=<font color="red">zeros</font>(3),
    <font color="blue">final </font>I_IC,
    <font color="blue">final </font>consMaterial=Conservation.IC,
    <font color="blue">final </font>consTransX=Conservation.IC,
    <font color="blue">final </font>consTransY=Conservation.IC,
    <font color="blue">final </font>consTransZ=Conservation.IC,
    <font color="blue">final </font>tauprime=0,
    <font color="blue">final </font>beta=1,
    <font color="blue">final </font>zeta=1);
  <font color="darkgreen">// Note:  beta and zeta don&#39;t matter as long as they are nonzero.</font>

<font color="blue">end </font>SpeciesSolid;
</pre>
<hr>

<h2><img src="images/FCSys.Subregions.Species.SpeciesSolidI.png" alt="FCSys.Subregions.Species.SpeciesIsochoric" align=RIGHT border=1 width=80  height=80 >
<a name="FCSys.Subregions.Species.SpeciesIsochoric"></a><a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species">FCSys.Subregions.Species</a>.SpeciesIsochoric</h2>
<b><a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.Species">Species</a> model for an isochoric material</b><p>
<img src="images/FCSys.Subregions.Species.SpeciesSolidD.png" alt="FCSys.Subregions.Species.SpeciesIsochoric">

<h3>Information</h3>

<p>Please see the documentation of the <a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.Species">Species</a> model.</p><p>
Extends from <a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.Species">Species</a> (Model to exchange, transport, and store the material, momentum, and energy of one species).
<p>
<h3>Parameters</h3>
<p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Type</th><th>Name</th><th>Default</th><th>Description</th></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Geometry</td></tr>
<tr><td>Integer</td><td>n_faces</td><td>1</td><td>Number of pairs of faces (<i>n</i><sub>faces</sub>)</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Material properties</td></tr>
<tr><TD colspan="2">replaceable package Data</td><td>Characteristics.BaseClasses&hellip;.</td><td>Characteristic data</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TimeAbsolute">TimeAbsolute</a></td><td>tauprime</td><td>Data.tauprime(T, v)</td><td>Phase change interval (&tau;&prime;) [T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Mobility">Mobility</a></td><td>mu</td><td>Data.mu(T, v)</td><td>Mobility (&mu;) [N.T/m]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TimeAbsolute">TimeAbsolute</a></td><td>nu</td><td>Data.nu(T, v)</td><td>Thermal independity (&nu;) [T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.ResistivityMaterial">ResistivityMaterial</a></td><td>eta</td><td>1</td><td>Material resistivity (&eta;) [T/l2]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Fluidity">Fluidity</a></td><td>beta</td><td>Data.beta(T, v)</td><td>Dynamic compressibility (&beta;) [l.T/m]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Fluidity">Fluidity</a></td><td>zeta</td><td>Data.zeta(T, v)</td><td>Fluidity (&zeta;) [l.T/m]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.ResistivityThermal">ResistivityThermal</a></td><td>theta</td><td>Data.theta(T, v)</td><td>Thermal resistivity (&theta;) [l.T/N]</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=4><b>Assumptions</b></td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Axes with upstream discretization</td></tr>
<tr><td>Boolean</td><td>upstreamX</td><td>true</td><td>X</td></tr>
<tr><td>Boolean</td><td>upstreamY</td><td>true</td><td>Y</td></tr>
<tr><td>Boolean</td><td>upstreamZ</td><td>true</td><td>Z</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Formulation of conservation equations</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.Conservation">Conservation</a></td><td>consMaterial</td><td>Conservation.Dynamic</td><td>Material</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.Conservation">Conservation</a></td><td>consTransX</td><td>Conservation.Dynamic</td><td>X-axis translational momentum</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.Conservation">Conservation</a></td><td>consTransY</td><td>Conservation.Dynamic</td><td>Y-axis translational momentum</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.Conservation">Conservation</a></td><td>consTransZ</td><td>Conservation.Dynamic</td><td>Z-axis translational momentum</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.Conservation">Conservation</a></td><td>consEnergy</td><td>Conservation.Dynamic</td><td>Energy</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Flow conditions</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">NumberAbsolute</a></td><td>Nu_Phi[Axis]</td><td>{4,4,4}</td><td>Translational Nusselt numbers (<b><i>Nu</i><sub>&Phi;</sub></b>) [1]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">NumberAbsolute</a></td><td>Nu_Q</td><td>1</td><td>Thermal Nusselt number (<i>Nu</i><sub><i>Q</i></sub>) [1]</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=4><b>Initialization</b></td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Material and energy</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitScalar">InitScalar</a></td><td>initMaterial</td><td>InitScalar.Volume</td><td>Method of initializing the material state</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitScalar">InitScalar</a></td><td>initEnergy</td><td>InitScalar.Temperature</td><td>Method of initializing the thermal state</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Amount">Amount</a></td><td>N_IC</td><td>&nbsp;</td><td>Initial particle number (<i>N</i><sub>IC</sub>) [N]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Density">Density</a></td><td>rho_IC</td><td>&nbsp;</td><td>Initial density (&rho;<sub>IC</sub>) [N/l3]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Volume">Volume</a></td><td>V_IC</td><td>&nbsp;</td><td>Initial volume (<i>V</i><sub>IC</sub>) [l3]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PressureAbsolute">PressureAbsolute</a></td><td>p_IC</td><td>&nbsp;</td><td>Initial pressure (<i>p</i><sub>IC</sub>) [m/(l.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureAbsolute">TemperatureAbsolute</a></td><td>T_IC</td><td>&nbsp;</td><td>Initial temperature (<i>T</i><sub>IC</sub>) [l2.m/(N.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Potential</a></td><td>h_IC</td><td>&nbsp;</td><td>Initial specific enthalpy (<i>h</i><sub>IC</sub>) [l2.m/(N.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Potential</a></td><td>g_IC</td><td>&nbsp;</td><td>Initial Gibbs potential (<i>g</i><sub>IC</sub>) [l2.m/(N.T2)]</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Translational momentum</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitTranslational">InitTranslational</a></td><td>initTransX</td><td>InitTranslational.Velocity</td><td>Method of initializing the x-axis state</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitTranslational">InitTranslational</a></td><td>initTransY</td><td>InitTranslational.Velocity</td><td>Method of initializing the y-axis state</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitTranslational">InitTranslational</a></td><td>initTransZ</td><td>InitTranslational.Velocity</td><td>Method of initializing the z-axis state</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Velocity">Velocity</a></td><td>phi_IC[Axis]</td><td>{0,0,0}</td><td>Initial velocity (<b>&phi;</b><sub>IC</sub>) [l/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Current">Current</a></td><td>I_IC[Axis]</td><td>{0,0,0}</td><td>Initial current (<i><b>I</b></i><sub>IC</sub>) [N/T]</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=4><b>Advanced</b></td></tr>
<tr><td>Boolean</td><td>invertEOS</td><td>false</td><td>Invert the equation of state</td></tr>
</table>
<p>
<h3>Connectors</h3>
<p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Type</th><th>Name</th><th>Description</th></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Chemical">Chemical</a></td><td>chemical</td><td>Connector for reactions</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Physical">Physical</a></td><td>physical</td><td>Connector for phase change</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Inert">Inert</a></td><td>inert</td><td>Connector to directly couple velocity or temperature with other species</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.InertDalton">InertDalton</a></td><td>inertDalton</td><td>Connector for translational and thermal diffusive exchange, with additivity of pressure</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Face">Face</a></td><td>faces[n_faces, Side]</td><td>Connectors to transport material, translational momentum, and thermal energy through the boundaries</td></tr>
</table>
<p>
<h3>Modelica definition</h3>

<pre>
<font color="blue">model</font> SpeciesIsochoric <font color="darkgreen">
  &quot;<a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.Species">Species</a> model for an isochoric material&quot;</font>
  <font color="blue">extends </font><a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species.Species">Species</a>(
    invertEOS=false,
    initMaterial=InitScalar.Volume,
    <font color="blue">final </font>eta=1);

  <font color="darkgreen">// Note:  Pressure, which is the default material IC for the base model,</font>
  <font color="darkgreen">// can&#39;t be used to initialize an incompressible species.</font>

<font color="blue">end </font>SpeciesIsochoric;
</pre>
<hr>

<h2><img src="images/FCSys.Subregions.Species.SpeciesSolidI.png" alt="FCSys.Subregions.Species.Species" align=RIGHT border=1 width=80  height=80 >
<a name="FCSys.Subregions.Species.Species"></a><a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species">FCSys.Subregions.Species</a>.Species</h2>
<b>Model to exchange, transport, and store the material, momentum, and energy of one species</b><p>
<img src="images/FCSys.Subregions.Species.SpeciesSolidD.png" alt="FCSys.Subregions.Species.Species">

<h3>Information</h3>

<p>This model is based on the following fixed assumptions:
    <ol>
       <li>All faces are rectangular.
       <li>The material is orthorhombic.  This implies that a gradient which induces diffusion
       along an axis does not induce diffusion along axes orthogonal to it
       [<a href="FCSys_UsersGuide.html#FCSys.UsersGuide.References">Bejan2006</a>,
       pp. 691&ndash;692].</li>
       <li>The coordinate system (x, y, z) is aligned with the principle
       axes of transport.  For example if the species is stratified, then the
       layers must be parallel to one of the planes in the rectilinear
       grid.</li>
       <li>The factors that may cause anisotropic behavior (<b><i>k</i></b>)
          are common to material, translational, and thermal transport.</li>
       <li>There is no radiative heat transfer (or else it must be linearized).</li>
       <li>Rotational momentum is not exchanged, transported, or stored.</li>
       <li>For the purpose of the material, translational momentum, and energy balances, the
       cross sectional areas of the faces are assumed to be the full cross-sectional
       areas of the subregion.  If multiple phases are present, then the areas are
       actually smaller.</li>
    </ol>
    Other assumptions are optional via the parameters.</p>

    <p><a href="#Fig1">Figure 1</a> shows how instances of
    <a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species">Species</a> models (derived from this
    model) are
    connected within a <a href="FCSys_Subregions.html#FCSys.Subregions">Subregion</a>.  A single species in
    a single phase is called a <i>configuration</i>. The
    generalized resistances (<i>R</i>) affect the phase change rate, forces, and heat flow rates
    associated with differences in activity, velocity, and temperature (respectively) between
    each configuration and a common node.  These exchange processes are diffusive.

    <p>In general, the resistances are included within the
    <a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species">Species</a> model.  For reactions, however,
    the rate equation is more complex and is included in the
    <a href="FCSys_Subregions.html#FCSys.Subregions.Reaction">Reaction</a> model.</p>

    <p>Translational momentum and thermal energy are advected as material is exchanged
    due to phase change or reactions.  This occurs at the velocity (&phi;) and specific entropy-temperature
    product (<i>sT</i>) of the reactants (source configurations), where the reactant/product designation
    depends on the current conditions.</p>

    <p>The advective exchange is modeled using <code>stream</code> connectors
    (<a href="FCSys_Connectors.html#FCSys.Connectors.Physical">Physical</a> and
    <a href="FCSys_Connectors.html#FCSys.Connectors.Chemical">Chemical</a>).
  The rate of advection of translational momentum is the
  product of the velocity of the source (&phi;) and the mass flow rate
  (<i>m</i><i>N&#775;</i>).  The rate of thermal advection is the
  specific entropy-temperature product of the source (<i>sT</i>) times the rate of
  material exchange
  (<i>N&#775;</i>).  If there are multiple sources, then
  their contributions are additive.  If there are multiple sinks, then
  translational momentum is split on a mass basis and the thermal stream is split
  on a particle-number basis.</p>

    <p align=center id="Fig1"><img src="images/Exchange.png">
<br>Figure 1:  Exchange of a quantity (material, translational momentum, or thermal energy) among configurations
    (A, B, and C) within a subregion.</p>

    <p><a href="#Fig2">Figure 2</a> shows how
    a configuration
    is connected between neighboring instances of a
    <a href="FCSys_Subregions.html#FCSys.Subregions.Subregion">Subregion</a>.
    Material, translational momentum, and thermal energy are transported by both advection and diffusion.
    Upstream discretization is applied if it is enabled via the <code>upstreamX</code>,
    etc. parameters.  Like for exchange, the transport resistances are inside the
    <a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species">Species</a> model.</p>

    <p align=center id="Fig2"><img src="images/Transport.png">
<br>Figure 2:  Transport of a quantity associated with the same configuration
    between subregions (1 and 2).</p>

<p>The <a href="FCSys_Subregions_Species.html#FCSys.Subregions.Species">Species</a> instances
    within a <a href="FCSys_Subregions_Phases.html#FCSys.Subregions.Phases">Phase</a> are combined by Dalton's law of
    partial pressures (see the
    <a href="FCSys_Connectors.html#FCSys.Connectors.InertDalton">InertDalton</a> connector), as shown
    in Figure 3a.  The pressures are additive, and each species is assumed to exist at the
    total extensive volume of the phase.  Within a <a href="FCSys_Subregions.html#FCSys.Subregions.Subregion">Subregion</a>,
    the <a href="FCSys_Subregions_Phases.html#FCSys.Subregions.Phases">Phases</a> are combined by Amagat's law of partial volumes
    (see the <a href="FCSys_Subregions.html#FCSys.Subregions.Volume">Volume</a> model), as shown
    in Figure 3b.  The volumes are additive, and each species is assumed to exist at the
    total pressure in the subregion.</p>

    <table border=0 cellspacing=0 cellpadding=2 align=center class=noBorder style="margin-left: auto; margin-right: auto;">
      <tr align=center class=noBorder>
        <td align=center class=noBorder style="margin-left: auto; margin-right: auto;">
          <img src="images/SharePressure.png">
<br>a:  Pressures of species (A, B, and C) are additive within a phase.
        </td>
        <td align=center class=noBorder style="margin-left: auto; margin-right: auto;">
          <img src="images/ShareVolume.png">
<br>b:  Volumes of phases (I, II, and III) are additive within a subregion.
        </td>
      </tr>
      <tr align=center class=noBorder style="margin-left: auto; margin-right: auto;">
        <td colspan=2 align=center class=noBorder>Figure 3: Methods of attributing pressure and volume.</td>
      </tr>
    </table>

    <p>Notes regarding the parameters:
    <ul>
    <li>Here (and in the rest of <a href="index.html#FCSys">FCSys</a>), the <i>specific</i>
    adjective means that the following extensive quantity is divided by particle number.
    (<i>Massic</i> indicates a quantity divided by mass.)</li>
    <li>In general, if material resistivity, dynamic compressibility, fluidity, or thermal resistivity is zero, then
    it should be set as <code>final</code> so that index reduction may be performed.
    If two configurations
    are connected through their <code>inertDalton</code> connectors or faces
    and both have zero generalized resistivities for a
    quantity, then index reduction [<a href="FCSys_UsersGuide.html#FCSys.UsersGuide.References">Mattsson1993B</a>] is necessary.</li>
    <li>Even if an initialization parameter is not selected for explicit use,
    it may be used a guess value.</li>
    <li>The area fill factor (<b><i>k</i></b>) can be used to account for the effects of porosity and tortousity
    on the rate of transport.  It may reflect anisotropic properties, since it is a vector with independent components
    for each axis.
    By default, its components are unity.  The area fill factor should be adjusted directly with effective
    area and inversely with effective length.
    It affects all of the diffusive transport rates (material, translational, and
    thermal) by the same factor.</li>
    <li>If <code>Conservation.IC</code> is used for a state (via
    <code>consMaterial</code>, <code>consTransX</code>, <code>consTransY</code>,
    <code>consTransZ</code>, or <code>consEnergy</code>),
    then the associated initial condition (IC) will be applied forever instead of the
    corresponding conservation equation.
    If <code>consMaterial</code>, <code>consTransX</code>, <code>consTransY</code>, or <code>consTransZ</code> is
    <code>Conservation.IC</code>, then there may be a secondary effect on the energy conservation equation
    and thus temperature.
    In that case, it may help to set <code>consEnergy</code> to <code>Conservation.IC</code> so that
    the energy conservation equation is not imposed.</li>
    <li>If <code>consTransX</code>, <code>consTransY</code>, or <code>consTransZ</code> is
    <code>Conservation.Steady</code>, then the derivative of the corresponding component of velocity
    is treated as zero and removed from the translational momentum balance.  If <code>consEnergy</code> is
    <code>Conservation.Steady</code>, then <code>T*der(s) + M*phi*der(phi)</code> is treated as
    zero and removed from the energy balance.</li>
    <li>If a component of velocity is not included (via the outer <code>inclTrans[:]</code> parameter
    which maps to <code>{inclTransX, inclTransY, inclTransZ}</code> in the
    <a href="FCSys_Subregions_BaseClasses.html#FCSys.Subregions.BaseClasses.EmptySubregion">Subregion</a> model), then it
    is taken to be zero in each translational transport equation.  However, the corresponding forces
    in the <code>faces</code> connector array are not included in the momentum or energy balances.
    If it is necessary to set a component of velocity to zero but still include it in the energy balance, then
    set the corresponding component of <code>phi_IC</code> to zero and <code>consTransX</code>,
    <code>consTransY</code>, or <code>consTransZ</code> to <code>Conservation.IC</code>.</li>
    <li>If a subregion does not contain any compressible species, then pressure must be prescribed.
    Set <code>consMaterial</code> to <code>Conservation.IC</code> and <code>initMaterial</code>
    to <code>InitScalar.Pressure</code> for one of the species.</li>
    <li>The <code>start</code> values of the initial conditions for pressure and temperature
    (<i>p</i><sub>IC</sub> and <i>T</i><sub>IC</sub>) are the global default pressure and
    temperature (via the <code>outer</code> instance of the <a href="FCSys_Conditions.html#FCSys.Conditions.Environment">Environment</a> model).
    The <code>start</code> values of the initial conditions for
    other intensive properties (&rho;<sub>IC</sub>, <i>h</i><sub>IC</sub>, and
    <i>g</i><sub>IC</sub>) are related to the initial pressure and temperature
    by the characteristics of the species.  The <code>start</code> value of the
    initial condition for the extensive volume (<i>V</i><sub>IC</sub>) is the volume of the
    subregion.  The <code>start</code> value for particle number (<i>N</i><sub>IC</sub>)
    is related to it via the material characteristics and the initial pressure and temperature.
    In order to apply other values for any of these initial conditions,
    it may be necessary to do so before translating the model.</li>
    <li>Upstream discretization may be applied to translational and thermal transport
    using (<code>upstreamX=true</code>, etc.).  Otherwise, the central difference
    scheme is used.  The central difference scheme
    is always used for material diffusion.</li>
    <li>If <code>invertEOS</code> is <code>true</code>, then the equation of state is implemented with pressure
    as a function of temperature and specific volume.  Otherwise, specific volume is a function of temperature
    and pressure.</li></p>

    <p>In the <code>faces</code> connector array, the transverse translational flow (<i>m</i>&Phi;dot) is only the
    force due to diffusion.  Translational advection is calculated from the velocity and the material current.
    The thermal flow (<i>Q&#775;</i>) is only the rate of heat transfer due to diffusion.  The advection of
    thermal energy is determined from the thermodynamic state at the boundary and the material current.</p>

**Discuss thermal Nusselt number.  Default is 1 (conduction); use 3.66 or 4.23 for internal flow if uniform
temperature or uniform heat flux.

    <p>In evaluating the dynamics of a phase, it is typically assumed that all of the species
    exist at the same velocity and temperature.  The translational and thermal time constants
    are usually much shorter than the time span of interest due to the very small coupling
    resistances.  If this is the case, connect the <code>inert</code>
    connectors of the species.  This will reduce the index of the problem.</p>

    <p>For the variables that relate to transport,
    the first index is the axis and the second index is the side.  The sides
    are ordered from negative to positive, according to the
    <a href="FCSys_BaseClasses.html#FCSys.BaseClasses.Side">Side</a> enumeration.
    Velocity and force are additionally indexed by
    the orientation of the momentum with respect to the face.
    The orientations are ordered in Cartesian space starting with the normal axis,
    according to the
    <a href="FCSys_BaseClasses.html#FCSys.BaseClasses.Orientation">Orientation</a> enumeration.</p>
    <p>
Extends from <a href="FCSys_BaseClasses_Icons_Names.html#FCSys.BaseClasses.Icons.Names.Top4">FCSys.BaseClasses.Icons.Names.Top4</a>.
<p>
<h3>Parameters</h3>
<p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Type</th><th>Name</th><th>Default</th><th>Description</th></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Geometry</td></tr>
<tr><td>Integer</td><td>n_faces</td><td>1</td><td>Number of pairs of faces (<i>n</i><sub>faces</sub>)</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Material properties</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TimeAbsolute">TimeAbsolute</a></td><td>tauprime</td><td>Data.tauprime(T, v)</td><td>Phase change interval (&tau;&prime;) [T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Mobility">Mobility</a></td><td>mu</td><td>Data.mu(T, v)</td><td>Mobility (&mu;) [N.T/m]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TimeAbsolute">TimeAbsolute</a></td><td>nu</td><td>Data.nu(T, v)</td><td>Thermal independity (&nu;) [T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.ResistivityMaterial">ResistivityMaterial</a></td><td>eta</td><td>Data.eta(T, v)</td><td>Material resistivity (&eta;) [T/l2]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Fluidity">Fluidity</a></td><td>beta</td><td>Data.beta(T, v)</td><td>Dynamic compressibility (&beta;) [l.T/m]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Fluidity">Fluidity</a></td><td>zeta</td><td>Data.zeta(T, v)</td><td>Fluidity (&zeta;) [l.T/m]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.ResistivityThermal">ResistivityThermal</a></td><td>theta</td><td>Data.theta(T, v)</td><td>Thermal resistivity (&theta;) [l.T/N]</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=4><b>Assumptions</b></td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Axes with upstream discretization</td></tr>
<tr><td>Boolean</td><td>upstreamX</td><td>true</td><td>X</td></tr>
<tr><td>Boolean</td><td>upstreamY</td><td>true</td><td>Y</td></tr>
<tr><td>Boolean</td><td>upstreamZ</td><td>true</td><td>Z</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Formulation of conservation equations</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.Conservation">Conservation</a></td><td>consMaterial</td><td>Conservation.Dynamic</td><td>Material</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.Conservation">Conservation</a></td><td>consTransX</td><td>Conservation.Dynamic</td><td>X-axis translational momentum</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.Conservation">Conservation</a></td><td>consTransY</td><td>Conservation.Dynamic</td><td>Y-axis translational momentum</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.Conservation">Conservation</a></td><td>consTransZ</td><td>Conservation.Dynamic</td><td>Z-axis translational momentum</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.Conservation">Conservation</a></td><td>consEnergy</td><td>Conservation.Dynamic</td><td>Energy</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Flow conditions</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">NumberAbsolute</a></td><td>Nu_Phi[Axis]</td><td>{4,4,4}</td><td>Translational Nusselt numbers (<b><i>Nu</i><sub>&Phi;</sub></b>) [1]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">NumberAbsolute</a></td><td>Nu_Q</td><td>1</td><td>Thermal Nusselt number (<i>Nu</i><sub><i>Q</i></sub>) [1]</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=4><b>Initialization</b></td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Material and energy</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitScalar">InitScalar</a></td><td>initMaterial</td><td>InitScalar.Pressure</td><td>Method of initializing the material state</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitScalar">InitScalar</a></td><td>initEnergy</td><td>InitScalar.Temperature</td><td>Method of initializing the thermal state</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Amount">Amount</a></td><td>N_IC</td><td>&nbsp;</td><td>Initial particle number (<i>N</i><sub>IC</sub>) [N]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Density">Density</a></td><td>rho_IC</td><td>&nbsp;</td><td>Initial density (&rho;<sub>IC</sub>) [N/l3]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Volume">Volume</a></td><td>V_IC</td><td>&nbsp;</td><td>Initial volume (<i>V</i><sub>IC</sub>) [l3]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PressureAbsolute">PressureAbsolute</a></td><td>p_IC</td><td>&nbsp;</td><td>Initial pressure (<i>p</i><sub>IC</sub>) [m/(l.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureAbsolute">TemperatureAbsolute</a></td><td>T_IC</td><td>&nbsp;</td><td>Initial temperature (<i>T</i><sub>IC</sub>) [l2.m/(N.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Potential</a></td><td>h_IC</td><td>&nbsp;</td><td>Initial specific enthalpy (<i>h</i><sub>IC</sub>) [l2.m/(N.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Potential</a></td><td>g_IC</td><td>&nbsp;</td><td>Initial Gibbs potential (<i>g</i><sub>IC</sub>) [l2.m/(N.T2)]</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Translational momentum</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitTranslational">InitTranslational</a></td><td>initTransX</td><td>InitTranslational.Velocity</td><td>Method of initializing the x-axis state</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitTranslational">InitTranslational</a></td><td>initTransY</td><td>InitTranslational.Velocity</td><td>Method of initializing the y-axis state</td></tr>
<tr><td><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitTranslational">InitTranslational</a></td><td>initTransZ</td><td>InitTranslational.Velocity</td><td>Method of initializing the z-axis state</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Velocity">Velocity</a></td><td>phi_IC[Axis]</td><td>{0,0,0}</td><td>Initial velocity (<b>&phi;</b><sub>IC</sub>) [l/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Current">Current</a></td><td>I_IC[Axis]</td><td>{0,0,0}</td><td>Initial current (<i><b>I</b></i><sub>IC</sub>) [N/T]</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=4><b>Advanced</b></td></tr>
<tr><td>Boolean</td><td>invertEOS</td><td>true</td><td>Invert the equation of state</td></tr>
</table>
<p>
<h3>Connectors</h3>
<p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Type</th><th>Name</th><th>Description</th></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Chemical">Chemical</a></td><td>chemical</td><td>Connector for reactions</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Physical">Physical</a></td><td>physical</td><td>Connector for phase change</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Inert">Inert</a></td><td>inert</td><td>Connector to directly couple velocity or temperature with other species</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.InertDalton">InertDalton</a></td><td>inertDalton</td><td>Connector for translational and thermal diffusive exchange, with additivity of pressure</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Face">Face</a></td><td>faces[n_faces, Side]</td><td>Connectors to transport material, translational momentum, and thermal energy through the boundaries</td></tr>
</table>
<p>
<h3>Modelica definition</h3>

<pre>
<font color="blue">model</font> Species <font color="darkgreen">
  &quot;Model to exchange, transport, and store the material, momentum, and energy of one species&quot;</font>
  <font color="blue">import </font><a href="FCSys_BaseClasses_Utilities.html#FCSys.BaseClasses.Utilities.cartWrap">FCSys.BaseClasses.Utilities.cartWrap</a>;
  <font color="blue">import </font><a href="FCSys_BaseClasses_Utilities.html#FCSys.BaseClasses.Utilities.inSign">FCSys.BaseClasses.Utilities.inSign</a>;
  <font color="blue">import </font><a href="FCSys_BaseClasses_Utilities.html#FCSys.BaseClasses.Utilities.Delta">FCSys.BaseClasses.Utilities.Delta</a>;
  <font color="blue">import </font><a href="FCSys_BaseClasses_Utilities.html#FCSys.BaseClasses.Utilities.Sigma">FCSys.BaseClasses.Utilities.Sigma</a>;
  <font color="blue">import </font>assert = <a href="FCSys_BaseClasses_Utilities.html#FCSys.BaseClasses.Utilities.assertEval">FCSys.BaseClasses.Utilities.assertEval</a>;
  <font color="blue">extends </font><a href="FCSys_BaseClasses_Icons_Names.html#FCSys.BaseClasses.Icons.Names.Top4">FCSys.BaseClasses.Icons.Names.Top4</a>;

  <font color="darkgreen">// Geometry</font>
  <font color="blue">parameter </font>Integer n_faces(
    min=1,
    max=3) = 1 <font color="darkgreen">
    &quot;Number of pairs of faces (<i>n</i><sub>faces</sub>)&quot;</font>;
  <font color="darkgreen">// Note:  This can&#39;t be an outer parameter in Dymola 7.4.</font>

  <font color="darkgreen">// Material properties</font>
  <font color="blue">replaceable </font><font color="blue">package</font> Data = <a href="FCSys_Characteristics_BaseClasses_Characteristic.html#FCSys.Characteristics.BaseClasses.Characteristic">Characteristics.BaseClasses.Characteristic</a> <font color="blue">
    constrainedby </font>Characteristics.BaseClasses.Characteristic <font color="darkgreen">
    &quot;Characteristic data&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.TimeAbsolute">Q.TimeAbsolute</a> tauprime(nominal=1e-6*U.s) = <font color="red">Data.tauprime</font>(T, v) <font color="darkgreen">
    &quot;Phase change interval (&tau;&prime;)&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Mobility">Q.Mobility</a> mu(nominal=0.1*U.C*U.s/U.kg) = <font color="red">Data.mu</font>(T, v) <font color="darkgreen">
    &quot;Mobility (&mu;)&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.TimeAbsolute">Q.TimeAbsolute</a> nu(nominal=1e-9*U.s) = <font color="red">Data.nu</font>(T, v) <font color="darkgreen">
    &quot;Thermal independity (&nu;)&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.ResistivityMaterial">Q.ResistivityMaterial</a> eta(nominal=10e-6*U.s/U.m^2) = <font color="red">Data.eta</font>(T, v) <font color="darkgreen">
    &quot;Material resistivity (&eta;)&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Fluidity">Q.Fluidity</a> beta(nominal=10*U.cm*U.s/U.g) = <font color="red">Data.beta</font>(T, v) <font color="darkgreen">
    &quot;Dynamic compressibility (&beta;)&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Fluidity">Q.Fluidity</a> zeta(nominal=10*U.cm*U.s/U.g) = <font color="red">Data.zeta</font>(T, v) <font color="darkgreen">
    &quot;Fluidity (&zeta;)&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.ResistivityThermal">Q.ResistivityThermal</a> theta(nominal=10*U.cm/U.A) = <font color="red">Data.theta</font>(T, v) <font color="darkgreen">
    &quot;Thermal resistivity (&theta;)&quot;</font>;

  <font color="darkgreen">// Assumptions</font>
  <font color="darkgreen">// -----------</font>
  <font color="darkgreen">// Upstream discretization</font>
  <font color="blue">parameter </font>Boolean upstreamX=true <font color="darkgreen">&quot;X&quot;</font>;
  <font color="blue">parameter </font>Boolean upstreamY=true <font color="darkgreen">&quot;Y&quot;</font>;
  <font color="blue">parameter </font>Boolean upstreamZ=true <font color="darkgreen">&quot;Z&quot;</font>;
  <font color="darkgreen">//</font>
  <font color="darkgreen">// Dynamics</font>
  <font color="blue">parameter </font><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.Conservation">Conservation</a> consMaterial=Conservation.Dynamic <font color="darkgreen">&quot;Material&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.Conservation">Conservation</a> consTransX=Conservation.Dynamic <font color="darkgreen">
    &quot;X-axis translational momentum&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.Conservation">Conservation</a> consTransY=Conservation.Dynamic <font color="darkgreen">
    &quot;Y-axis translational momentum&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.Conservation">Conservation</a> consTransZ=Conservation.Dynamic <font color="darkgreen">
    &quot;Z-axis translational momentum&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.Conservation">Conservation</a> consEnergy=Conservation.Dynamic <font color="darkgreen">&quot;Energy&quot;</font>;
  <font color="darkgreen">// TODO:  If the static option isn&#39;t useful, remove it and go back</font>
  <font color="darkgreen">// to Boolean setMaterial, setTransX, etc.</font>
  <font color="darkgreen">//</font>
  <font color="darkgreen">// Flow conditions</font>
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">Q.NumberAbsolute</a> Nu_Phi[Axis]={4,4,4} <font color="darkgreen">
    &quot;Translational Nusselt numbers (<b><i>Nu</i><sub>&Phi;</sub></b>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">Q.NumberAbsolute</a> Nu_Q=1 <font color="darkgreen">
    &quot;Thermal Nusselt number (<i>Nu</i><sub><i>Q</i></sub>)&quot;</font>;

  <font color="darkgreen">// Initialization parameters</font>
  <font color="darkgreen">// -------------------------</font>
  <font color="darkgreen">// Scalar properties</font>
  <font color="blue">parameter </font><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitScalar">InitScalar</a> initMaterial=InitScalar.Pressure <font color="darkgreen">
    &quot;Method of initializing the material state&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitScalar">InitScalar</a> initEnergy=InitScalar.Temperature <font color="darkgreen">
    &quot;Method of initializing the thermal state&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Amount">Q.Amount</a> N_IC(start=V_IC*rho_IC) <font color="darkgreen">
    &quot;Initial particle number (<i>N</i><sub>IC</sub>)&quot;</font>;
  <font color="darkgreen">// Note:  This parameter is left enabled even it isn&#39;t used to</font>
  <font color="darkgreen">// explicitly initialize any states, since it&#39;s used as a guess value.</font>
  <font color="darkgreen">// Similar notes apply to some other initial conditions below.</font>
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Density">Q.Density</a> rho_IC(start=1/<font color="red">Data.v_Tp</font>(T_IC, p_IC)) <font color="darkgreen">
    &quot;Initial density (&rho;<sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Volume">Q.Volume</a> V_IC(start=<font color="red">product</font>(L)) <font color="darkgreen">
    &quot;Initial volume (<i>V</i><sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.PressureAbsolute">Q.PressureAbsolute</a> p_IC(start=environment.p) <font color="darkgreen">
    &quot;Initial pressure (<i>p</i><sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureAbsolute">Q.TemperatureAbsolute</a> T_IC(start=environment.T) <font color="darkgreen">
    &quot;Initial temperature (<i>T</i><sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Q.Potential</a> h_IC(start=<font color="red">Data.h</font>(T_IC, p_IC), displayUnit=&quot;kJ/mol&quot;) <font color="darkgreen">
    &quot;Initial specific enthalpy (<i>h</i><sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Q.Potential</a> g_IC(start=<font color="red">Data.g</font>(T_IC, p_IC), displayUnit=&quot;kJ/mol&quot;) <font color="darkgreen">
    &quot;Initial Gibbs potential (<i>g</i><sub>IC</sub>)&quot;</font>;
  <font color="darkgreen">//</font>
  <font color="darkgreen">// Velocity</font>
  <font color="blue">parameter </font><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitTranslational">InitTranslational</a> initTransX=InitTranslational.Velocity <font color="darkgreen">
    &quot;Method of initializing the x-axis state&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitTranslational">InitTranslational</a> initTransY=InitTranslational.Velocity <font color="darkgreen">
    &quot;Method of initializing the y-axis state&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitTranslational">InitTranslational</a> initTransZ=InitTranslational.Velocity <font color="darkgreen">
    &quot;Method of initializing the z-axis state&quot;</font>;
  <font color="darkgreen">// Note:  Dymola 7.4 doesn&#39;t provide pull-down lists for arrays of</font>
  <font color="darkgreen">// enumerations; therefore, a parameter is used for each axis.</font>
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Velocity">Q.Velocity</a> phi_IC[Axis]={0,0,0} <font color="darkgreen">
    &quot;Initial velocity (<b>&phi;</b><sub>IC</sub>)&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Current">Q.Current</a> I_IC[Axis]={0,0,0} <font color="darkgreen">
    &quot;Initial current (<i><b>I</b></i><sub>IC</sub>)&quot;</font>;

  <font color="darkgreen">// Advanced parameters</font>
  <font color="blue">parameter </font>Boolean invertEOS=true <font color="darkgreen">&quot;Invert the equation of state&quot;</font>;

  <font color="darkgreen">// Preferred states</font>
  <font color="darkgreen">// Note:  The start value for this variable (and others below) isn&#39;t fixed</font>
  <font color="darkgreen">// because the related initial condition is applied in the initial</font>
  <font color="darkgreen">// equation section.</font>
  <a href="FCSys_Quantities.html#FCSys.Quantities.Amount">Q.Amount</a> N(
    min=Modelica.Constants.small,
    nominal=4*U.C,
    <font color="blue">final </font>start=N_IC,
    <font color="blue">final </font>fixed=false,
    stateSelect=StateSelect.prefer) <font color="darkgreen">&quot;Particle number&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Velocity">Q.Velocity</a> phi[n_trans](
    <font color="blue">each </font>nominal=10*U.cm/U.s,
    <font color="blue">final </font>start=phi_IC[cartTrans],
    <font color="blue">each </font><font color="blue">final </font>fixed=false,
    <font color="blue">each </font>stateSelect=StateSelect.prefer) <font color="darkgreen">&quot;Velocity&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureAbsolute">Q.TemperatureAbsolute</a> T(
    nominal=300*U.K,
    <font color="blue">final </font>start=T_IC,
    <font color="blue">final </font>fixed=false,
    stateSelect=StateSelect.prefer) <font color="darkgreen">&quot;Temperature&quot;</font>;

  <font color="darkgreen">// Aliases (for common terms)</font>
  <a href="FCSys_Quantities.html#FCSys.Quantities.PressureAbsolute">Q.PressureAbsolute</a> p(
    nominal=U.atm,
    <font color="blue">final </font>start=p_IC,
    <font color="blue">final </font>fixed=false,
    stateSelect=StateSelect.never) <font color="darkgreen">&quot;Pressure&quot;</font>;
  <font color="darkgreen">// StateSelect.never avoids dynamic state selection of this variable and</font>
  <font color="darkgreen">// others below in Dymola 7.4.</font>
  <a href="FCSys_Quantities.html#FCSys.Quantities.Volume">Q.Volume</a> V(
    nominal=U.cc,
    <font color="blue">final </font>start=V_IC,
    <font color="blue">final </font>fixed=false,
    stateSelect=StateSelect.never) <font color="darkgreen">&quot;Volume&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Mass">Q.Mass</a> M(
    nominal=1e-3*U.g,
    <font color="blue">final </font>start=Data.m*N_IC,
    stateSelect=StateSelect.never) <font color="darkgreen">&quot;Mass&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.VolumeSpecific">Q.VolumeSpecific</a> v(
    nominal=U.cc/(4*U.C),
    <font color="blue">final </font>start=1/rho_IC,
    <font color="blue">final </font>fixed=false,
    stateSelect=StateSelect.never) <font color="darkgreen">&quot;Specific volume&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Q.Potential</a> h(
    nominal=U.V,
    <font color="blue">final </font>start=h_IC,
    <font color="blue">final </font>fixed=false,
    stateSelect=StateSelect.never) <font color="darkgreen">&quot;Specific enthalpy&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">Q.NumberAbsolute</a> s(
    nominal=10,
    <font color="blue">final </font>start=(h_IC - g_IC)/T_IC,
    stateSelect=StateSelect.never) <font color="darkgreen">&quot;Specific entropy&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Current">Q.Current</a> I[n_trans](
    <font color="blue">each </font>nominal=U.A,
    <font color="blue">final </font>start=I_IC[cartTrans],
    <font color="blue">each </font><font color="blue">final </font>fixed=false,
    stateSelect=StateSelect.never) <font color="darkgreen">&quot;Current&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Current">Q.Current</a> Ndot_faces[n_faces, Side](nominal=U.A, <font color="blue">final </font>start=<font color="red">outerProduct</font>(
        I_IC[cartFaces], {1,-1})) <font color="darkgreen">
    &quot;Total current into the faces (advection and diffusion)&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.PressureAbsolute">Q.PressureAbsolute</a> p_faces[n_faces, Side](<font color="blue">each </font>nominal=U.atm, <font color="blue">each </font>start=p_IC)
    <font color="darkgreen">&quot;Thermodynamic pressures at the faces&quot;</font>;

  <font color="darkgreen">// Auxiliary variables (for analysis)</font>
  <font color="darkgreen">// ----------------------------------</font>
  <font color="darkgreen">// Misc. properties and conditions</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Density">Q.Density</a> rho(stateSelect=StateSelect.never) = 1/v <font color="blue">if </font>environment.analysis
    <font color="darkgreen">&quot;Density&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Q.Potential</a> g(stateSelect=StateSelect.never) = chemical.mu <font color="blue">if </font>
    environment.analysis <font color="darkgreen">&quot;Electrochemical potential&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Amount">Q.Amount</a> S(stateSelect=StateSelect.never) = N*s <font color="blue">if </font>environment.analysis
    <font color="darkgreen">&quot;Entropy&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.PressureAbsolute">Q.PressureAbsolute</a> q[n_trans](<font color="blue">each </font>stateSelect=StateSelect.never) =
    Data.m*phi .* I ./ (2*A[cartTrans]) <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Dynamic pressure&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.CapacityThermalSpecific">Q.CapacityThermalSpecific</a> c_p(stateSelect=StateSelect.never) = <font color="red">
    Data.c_p</font>(T, p) <font color="blue">if </font>environment.analysis <font color="darkgreen">&quot;Isobaric specific heat capacity&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.CapacityThermalSpecific">Q.CapacityThermalSpecific</a> c_v(stateSelect=StateSelect.never) = <font color="red">
    Data.c_v</font>(T, p) <font color="blue">if </font>environment.analysis <font color="darkgreen">&quot;Isochoric specific heat capacity&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.PressureReciprocal">Q.PressureReciprocal</a> kappa(stateSelect=StateSelect.never) = <font color="red">Data.kappa</font>
    (T, p) <font color="blue">if </font>environment.analysis <font color="darkgreen">&quot;Isothermal compressibility&quot;</font>;
  <font color="darkgreen">//</font>
  <font color="darkgreen">// Time constants (only for the axes with translational momentum included;</font>
  <font color="darkgreen">// others are infinite)</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.TimeAbsolute">Q.TimeAbsolute</a> tau_NE(
    stateSelect=StateSelect.never,
    start=U.s) = kappa*tauprime*<font color="red">exp</font>((chemical.mu - g0)/T)*T/v <font color="blue">if </font>environment.analysis
    <font color="darkgreen">&quot;Time constant for phase change&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.TimeAbsolute">Q.TimeAbsolute</a> tau_PhiE(
    stateSelect=StateSelect.never,
    start=U.s) = Data.m*mu <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Time constant for translational exchange&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.TimeAbsolute">Q.TimeAbsolute</a> tau_QE(
    stateSelect=StateSelect.never,
    start=U.s) = c_p*nu <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Time constant for thermal exchange&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.TimeAbsolute">Q.TimeAbsolute</a> tau_NT[n_faces](
    <font color="blue">each </font>stateSelect=StateSelect.never,
    <font color="blue">each </font>start=U.s) = <font color="red">fill</font>(V*eta/2, n_faces) ./ Lprime[cartFaces] <font color="blue">if </font>
    environment.analysis <font color="darkgreen">&quot;Time constants for material transport&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.TimeAbsolute">Q.TimeAbsolute</a> tau_PhiT_perp[n_faces](
    <font color="blue">each </font>stateSelect=StateSelect.never,
    <font color="blue">each </font>start=U.s) = <font color="red">fill</font>(M*beta/2, n_faces) ./ Lprime[cartFaces] <font color="blue">if </font>
    environment.analysis <font color="darkgreen">&quot;Time constants for normal translational transport&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.TimeAbsolute">Q.TimeAbsolute</a> tau_PhiT_para[n_faces](
    <font color="blue">each </font>stateSelect=StateSelect.never,
    <font color="blue">each </font>start=U.s) = <font color="red">fill</font>(M*zeta/2, n_faces) ./ Lprime[cartFaces] <font color="blue">if </font>
    environment.analysis <font color="darkgreen">
    &quot;Time constants for transverse translational transport&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.TimeAbsolute">Q.TimeAbsolute</a> tau_QT[n_faces](
    <font color="blue">each </font>stateSelect=StateSelect.never,
    <font color="blue">each </font>start=U.s) = <font color="red">fill</font>(N*c_v*theta/2, n_faces) ./ Lprime[cartFaces] <font color="blue">if </font>
    environment.analysis <font color="darkgreen">&quot;Time constants for thermal transport&quot;</font>;
  <font color="darkgreen">//</font>
  <font color="darkgreen">// Peclet numbers (only for the axes with translational momentum included;</font>
  <font color="darkgreen">// others are zero)</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Number">Q.Number</a> Pe_N[n_trans](<font color="blue">each </font>stateSelect=StateSelect.never) = eta*v*I ./
    Lprime[cartTrans] <font color="blue">if </font>environment.analysis <font color="darkgreen">&quot;Material Peclet numbers&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Number">Q.Number</a> Pe_Phi_perp[n_trans](<font color="blue">each </font>stateSelect=StateSelect.never) =
    beta*Data.m*I ./ Lprime[cartTrans] <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Normal translational Peclet numbers&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Number">Q.Number</a> Pe_Phi_para[n_trans](<font color="blue">each </font>stateSelect=StateSelect.never) =
    zeta*Data.m*I ./ Lprime[cartTrans] <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Transverse translational Peclet numbers&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Number">Q.Number</a> Pe_Q[n_trans](<font color="blue">each </font>stateSelect=StateSelect.never) = theta*<font color="red">
    Data.c_v</font>(T, p)*I ./ Lprime[cartTrans] <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Thermal Peclet numbers&quot;</font>;
  <font color="darkgreen">//</font>
  <font color="darkgreen">// Bulk flow rates</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> mphiI[n_trans, n_trans](<font color="blue">each </font>stateSelect=StateSelect.never) = <font color="red">
    outerProduct</font>(I, Data.m*phi) <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Bulk rate of translational advection (1st index: transport axis, 2nd index: translational component)&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> hI[n_trans](<font color="blue">each </font>stateSelect=StateSelect.never) = h*I <font color="blue">if </font>
    environment.analysis <font color="darkgreen">&quot;Bulk enthalpy flow rate&quot;</font>;
  <font color="darkgreen">//</font>
  <font color="darkgreen">// Translational momentum balance</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> Ma[n_trans](<font color="blue">each </font>stateSelect=StateSelect.never) = M*(<font color="red">der</font>(phi)/
    U.s + environment.a[cartTrans]) + N*Data.z*environment.E[cartTrans] <font color="blue">if </font>
    environment.analysis <font color="darkgreen">
    &quot;Acceleration force (including acceleration due to body forces)&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> f_thermo[n_trans](<font color="blue">each </font>stateSelect=StateSelect.never) = {(<font color="blue">if </font>
    inclFaces[cartTrans[i]]<font color="blue"> then </font>-<font color="red">Delta</font>(p_faces[facesCart[cartTrans[i]], :])*A[
    cartTrans[i]]<font color="blue"> else </font>0) <font color="blue">for </font>i<font color="blue"> in </font>1:n_trans} <font color="darkgreen">&quot;Thermodynamic force&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> f_AE[n_trans](<font color="blue">each </font>stateSelect=StateSelect.never) = Data.m*((<font color="red">
    actualStream</font>(chemical.phi) - phi) .* chemical.Ndot + (<font color="red">actualStream</font>(physical.phi)
     - phi) .* physical.Ndot) <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Acceleration force due to advective exchange&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> f_DE[n_trans](<font color="blue">each </font>stateSelect=StateSelect.never) = inert.translational.mPhidot
     + inertDalton.mPhidot <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Friction from other configurations (diffusive exchange)&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> f_AT[n_trans](<font color="blue">each </font>stateSelect=StateSelect.never) = {<font color="red">sum</font>((
    faces[j, :].phi[<font color="red">cartWrap</font>(cartTrans[i] - cartFaces[j] + 1)] - {phi[i],phi[i]})
    *Ndot_faces[j, :]*Data.m <font color="blue">for </font>j<font color="blue"> in </font>1:n_faces) <font color="blue">for </font>i<font color="blue"> in </font>1:n_trans} <font color="blue">if </font>
    environment.analysis <font color="darkgreen">&quot;Acceleration force due to advective transport&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> f_DT[n_trans](<font color="blue">each </font>stateSelect=StateSelect.never) = {<font color="red">sum</font>(<font color="red">Sigma</font>
    (faces[j, :].mPhidot[<font color="red">cartWrap</font>(cartTrans[i] - cartFaces[j] + 1)]) <font color="blue">for </font>j<font color="blue"> in </font>1:
    n_faces) <font color="blue">for </font>i<font color="blue"> in </font>1:n_trans} <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Friction from other subregions (diffusive transport, including bulk viscosity)&quot;</font>;
  <font color="darkgreen">//</font>
  <font color="darkgreen">// Energy balance</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> Ndere(stateSelect=StateSelect.never) = (N*T*<font color="red">der</font>(s) + M*phi*<font color="red">der</font>
    (phi))/U.s <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Rate of energy storage (internal and kinetic) and boundary work at constant mass&quot;</font>;
  <font color="darkgreen">// Note that T*der(s) = der(u) + p*der(v).</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> Edot_AE(stateSelect=StateSelect.never) = (chemical.mu + <font color="red">
    actualStream</font>(chemical.sT) - h + (<font color="red">actualStream</font>(chemical.phi)*<font color="red">actualStream</font>(
    chemical.phi) - phi*phi)*Data.m/2)*chemical.Ndot + (physical.mu + <font color="red">
    actualStream</font>(physical.sT) - h + (<font color="red">actualStream</font>(physical.phi)*<font color="red">actualStream</font>(
    physical.phi) - phi*phi)*Data.m/2)*physical.Ndot <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Relative rate of energy (internal, flow, and kinetic) due to phase change and reaction&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> Edot_DE(stateSelect=StateSelect.never) = inert.translational.phi
    *inert.translational.mPhidot + inert.thermal.Qdot + inertDalton.phi*
    inertDalton.mPhidot + inertDalton.Qdot <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Rate of diffusion of energy from other configurations&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> Edot_AT(stateSelect=StateSelect.never) = <font color="red">sum</font>((<font color="red">Data.h</font>(faces[j,
    :].T, p_faces[j, :]) - {h,h})*Ndot_faces[j, :] + <font color="red">sum</font>((faces[j, :].phi[<font color="red">
    cartWrap</font>(cartTrans[i] - cartFaces[j] + 1)] .^ 2 - <font color="red">fill</font>(phi[i]^2, 2))*
    Ndot_faces[j, :]*Data.m/2 <font color="blue">for </font>i<font color="blue"> in </font>1:n_trans) <font color="blue">for </font>j<font color="blue"> in </font>1:n_faces) <font color="blue">if </font>
    environment.analysis <font color="darkgreen">
    &quot;Relative rate of energy (internal, flow, and kinetic) due to advective transport&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> Edot_DT(stateSelect=StateSelect.never) = <font color="red">sum</font>(<font color="red">sum</font>(faces[j, :].phi[<font color="red">
    cartWrap</font>(cartTrans[i] - cartFaces[j] + 1)]*faces[j, :].mPhidot[<font color="red">cartWrap</font>(
    cartTrans[i] - cartFaces[j] + 1)] <font color="blue">for </font>i<font color="blue"> in </font>1:n_trans) <font color="blue">for </font>j<font color="blue"> in </font>1:n_faces) + <font color="red">
    sum</font>(faces.Qdot) <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Rate of diffusion of energy from other subregions&quot;</font>;
  <font color="darkgreen">// Note:  The structure of the problem should not change if these</font>
  <font color="darkgreen">// auxiliary variables are included (hence StateSelect.never).</font>

  <a href="FCSys_Connectors.html#FCSys.Connectors.Chemical">Connectors.Chemical</a> chemical(
    <font color="blue">final </font>n_trans=n_trans,
    mu(start=g_IC, <font color="blue">final </font>fixed=false),
    phi(start=phi_IC[cartTrans], <font color="blue">each </font><font color="blue">final </font>fixed=false),
    sT(start=h_IC - g_IC, <font color="blue">final </font>fixed=false)) <font color="darkgreen">&quot;Connector for reactions&quot;</font>;
  <a href="FCSys_Connectors.html#FCSys.Connectors.Physical">Connectors.Physical</a> physical(
    <font color="blue">final </font>formula=Data.formula,
    <font color="blue">final </font>n_trans=n_trans,
    mu(start=g_IC, fixed=false),
    phi(<font color="blue">final </font>start=phi_IC[cartTrans], <font color="blue">each </font><font color="blue">final </font>fixed=false),
    sT(<font color="blue">final </font>start=h_IC - g_IC, <font color="blue">final </font>fixed=false)) <font color="darkgreen">
    &quot;Connector for phase change&quot;</font>;
  <a href="FCSys_Connectors.html#FCSys.Connectors.Inert">Connectors.Inert</a> inert(
    <font color="blue">final </font>n_trans=n_trans,
    translational(phi(<font color="blue">final </font>start=phi_IC[cartTrans], <font color="blue">each </font><font color="blue">final </font>fixed=false)),
    thermal(T(<font color="blue">final </font>start=T_IC, <font color="blue">final </font>fixed=false))) <font color="darkgreen">
    &quot;Connector to directly couple velocity or temperature with other species&quot;</font>;

  <a href="FCSys_Connectors.html#FCSys.Connectors.InertDalton">Connectors.InertDalton</a> inertDalton(
    <font color="blue">final </font>n_trans=n_trans,
    V(
      min=0,
      <font color="blue">final </font>start=V_IC,
      <font color="blue">final </font>fixed=false),
    p(<font color="blue">final </font>start=p_IC, <font color="blue">final </font>fixed=false),
    phi(start=phi_IC[cartTrans]),
    T(start=T_IC)) <font color="darkgreen">
    &quot;Connector for translational and thermal diffusive exchange, with additivity of pressure&quot;</font>;
  <a href="FCSys_Connectors.html#FCSys.Connectors.Face">Connectors.Face</a> faces[n_faces, Side](
    rho(<font color="blue">each </font>start=rho_IC),
    Ndot(start=<font color="red">outerProduct</font>(I_IC[cartFaces], {1,-1})),
    phi(start={<font color="red">fill</font>({phi_IC[<font color="red">cartWrap</font>(cartFaces[i] + orientation - 1)] <font color="blue">for </font>
          orientation<font color="blue"> in </font>Orientation}, 2) <font color="blue">for </font>i<font color="blue"> in </font>1:n_faces}),
    mPhidot(<font color="blue">each </font>start=0),
    T(<font color="blue">each </font>start=T_IC),
    Qdot(<font color="blue">each </font>start=0)) <font color="darkgreen">
    &quot;Connectors to transport material, translational momentum, and thermal energy through the boundaries&quot;</font>;

<font color="darkgreen">// Geometric parameters</font>

<font color="blue">protected </font>
  <font color="blue">outer </font><font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Length">Q.Length</a> L[Axis] <font color="darkgreen">&quot;Lengths&quot;</font>;
  <font color="blue">outer </font><font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Area">Q.Area</a> A[Axis] <font color="darkgreen">&quot;Cross-sectional areas&quot;</font>;
  <font color="blue">outer </font><font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Length">Q.Length</a> Lprime[Axis] <font color="darkgreen">
    &quot;Effective cross-sectional area per length&quot;</font>;
  <font color="blue">outer </font><font color="blue">parameter </font>Boolean inclTrans[Axis] <font color="darkgreen">
    &quot;true, if each component of translational momentum is included&quot;</font>;
  <font color="blue">outer </font><font color="blue">parameter </font>Boolean inclFaces[Axis] <font color="darkgreen">
    &quot;true, if each pair of faces is included&quot;</font>;
  <font color="blue">outer </font><font color="blue">parameter </font>Boolean inclRot[3] <font color="darkgreen">
    &quot;true, if each axis of rotation has all its tangential faces included&quot;</font>;
  <font color="darkgreen">// Note:  The size is also Axis, but it can&#39;t be specified here due to</font>
  <font color="darkgreen">// an error in Dymola 7.4 (failure in check of Phase models).</font>
  <font color="blue">outer </font><font color="blue">parameter </font>Integer n_trans <font color="darkgreen">
    &quot;Number of components of translational momentum&quot;</font>;
  <font color="blue">outer </font><font color="blue">parameter </font>Integer cartTrans[:] <font color="darkgreen">
    &quot;Cartesian-axis indices of the components of translational momentum&quot;</font>;
  <font color="blue">outer </font><font color="blue">parameter </font>Integer cartFaces[:] <font color="darkgreen">
    &quot;Cartesian-axis indices of the pairs of faces&quot;</font>;
  <font color="blue">outer </font><font color="blue">parameter </font>Integer cartRot[:] <font color="darkgreen">
    &quot;Cartesian-axis indices of the components of rotational momentum&quot;</font>;
  <font color="darkgreen">// Note:  The size of cartTrans, cartFaces, and cartRot is n_trans,</font>
  <font color="darkgreen">// but it can&#39;t be specified here due to an error in Dymola 7.4.</font>
  <font color="blue">outer </font><font color="blue">parameter </font>Integer transCart[3] <font color="darkgreen">
    &quot;Translational-momentum-component indices of the Cartesian axes&quot;</font>;
  <font color="darkgreen">// Note:  The size is also Axis, but it can&#39;t be specified here due to</font>
  <font color="darkgreen">// an error in Dymola 7.4 (failure in check of Phase models).</font>
  <font color="blue">outer </font><font color="blue">parameter </font>Integer facesCart[Axis] <font color="darkgreen">
    &quot;Face-pair indices of the Cartesian axes&quot;</font>;
  <font color="blue">final </font><font color="blue">parameter </font>Boolean upstream[Axis]={upstreamX,upstreamY,upstreamZ} <font color="darkgreen">
    &quot;true, if each Cartesian axis uses upstream discretization&quot;</font>;
  <font color="blue">final </font><font color="blue">parameter </font><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.Conservation">Conservation</a> consTrans[Axis]={consTransX,consTransY,
      consTransZ} <font color="darkgreen">&quot;Formulation of the translational conservation equations&quot;</font>;
  <font color="blue">final </font><font color="blue">parameter </font><a href="FCSys_Subregions_Species_BaseClasses.html#FCSys.Subregions.Species.BaseClasses.InitTranslational">InitTranslational</a> initTrans[Axis]={initTransX,initTransY,
      initTransZ} <font color="darkgreen">&quot;Initialization methods for translational momentum&quot;</font>;

  <font color="darkgreen">// Additional aliases (for common terms)</font>
  <a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Q.Potential</a> g0(
    nominal=U.V,
    <font color="blue">final </font>start=g_IC,
    <font color="blue">final </font>fixed=false,
    stateSelect=StateSelect.never) <font color="darkgreen">&quot;Gibbs potential at reference pressure&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> faces_mPhidot[n_faces, Side, 2] <font color="darkgreen">&quot;Directly calculated shear forces&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Velocity">Q.Velocity</a> phi_actual_chemical[n_trans] <font color="darkgreen">&quot;Velocity of the chemical stream&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Velocity">Q.Velocity</a> phi_actual_physical[n_trans] <font color="darkgreen">&quot;Velocity of the physical stream&quot;</font>;
  <font color="darkgreen">// Note:  Dymola 7.4 can&#39;t individually index the components of a</font>
  <font color="darkgreen">// stream variable (e.g., actualStream(chemical.phi[i])), so these</font>
  <font color="darkgreen">// variables are necessary.</font>

  <font color="blue">outer </font><a href="FCSys_Conditions.html#FCSys.Conditions.Environment">Conditions.Environment</a> environment <font color="darkgreen">&quot;Environmental conditions&quot;</font>;

<font color="blue">initial </font><font color="blue">equation </font>
  <font color="darkgreen">// Check the initialization methods.</font>
  <font color="red">assert</font>(initMaterial &lt;&gt; initEnergy<font color="blue"> or </font>initMaterial == InitScalar.None<font color="blue"> or </font>
    consMaterial == Conservation.Steady<font color="blue"> or </font>consEnergy == Conservation.Steady, &quot;The initialization methods for material and energy must be different (unless None).&quot;);
  <font color="blue">if </font><font color="blue">not </font>Data.isCompressible<font color="blue"> then</font>
    <font color="red">assert</font>(initMaterial &lt;&gt; InitScalar.Pressure<font color="blue"> and </font>initMaterial &lt;&gt; InitScalar.PressureSS<font color="blue">
       or </font>consMaterial == Conservation.IC<font color="blue"> or </font>consMaterial == Conservation.Steady,
      &quot;The material is incompressible,
yet the initialization method for material of &quot; + Data.formula + &quot; involves pressure.&quot;);
    <font color="red">assert</font>(initEnergy &lt;&gt; InitScalar.Pressure<font color="blue"> and </font>initEnergy &lt;&gt; InitScalar.PressureSS<font color="blue">
       or </font>consEnergy == Conservation.IC<font color="blue"> or </font>consEnergy == Conservation.Steady, &quot;The material is incompressible,
yet the initialization method for energy of &quot; + Data.formula + &quot; involves pressure.&quot;);
    <font color="blue">if </font><font color="blue">not </font>Data.hasThermalExpansion<font color="blue"> then</font>
      <font color="red">assert</font>(initMaterial &lt;&gt; InitScalar.Density<font color="blue"> and </font>initMaterial &lt;&gt; InitScalar.DensitySS<font color="blue">
         or </font>consMaterial == Conservation.IC<font color="blue"> or </font>consMaterial == Conservation.Steady,
        &quot;The material is isochoric,
yet the initialization method for material of &quot; + Data.formula + &quot; involves density.&quot;);
      <font color="red">assert</font>(initEnergy &lt;&gt; InitScalar.Density<font color="blue"> and </font>initEnergy &lt;&gt; InitScalar.DensitySS<font color="blue">
         or </font>consEnergy == Conservation.IC<font color="blue"> or </font>consEnergy == Conservation.Steady,
        &quot;The material is isochoric,
yet the initialization method for energy of &quot; + Data.formula + &quot; involves density.&quot;);
    <font color="blue">end if</font>;
  <font color="blue">end if</font>;
  <font color="darkgreen">// **Move these below.</font>

  <font color="darkgreen">// Material</font>
  <font color="blue">if </font>consMaterial == Conservation.IC<font color="blue"> then</font>
    <font color="darkgreen">// Ensure that a condition is selected since the state is prescribed.</font>
    <font color="red">assert</font>(initMaterial &lt;&gt; InitScalar.None, &quot;The material state of &quot; + Data.formula
       + &quot; is prescribed,
yet its condition is not defined.  Choose any condition besides None.&quot;);
  <font color="blue">elseif </font>consMaterial == Conservation.Dynamic<font color="blue"> then</font>
    <font color="darkgreen">// Initialize since there&#39;s a time-varying state.</font>
    <font color="blue">if </font>initMaterial == InitScalar.Amount<font color="blue"> then</font>
      N = N_IC;
    <font color="blue">elseif </font>initMaterial == InitScalar.AmountSS<font color="blue"> then</font>
      <font color="red">der</font>(N) = 0;
    <font color="blue">elseif </font>initMaterial == InitScalar.Density<font color="blue"> then</font>
      1/v = rho_IC;
      <font color="red">assert</font>(Data.isCompressible, Data.formula + &quot; is incompressible,
yet its material initialization involves density.&quot;);
    <font color="blue">elseif </font>initMaterial == InitScalar.DensitySS<font color="blue"> then</font>
      <font color="red">der</font>(1/v) = 0;
      <font color="red">assert</font>(Data.isCompressible, Data.formula + &quot; is incompressible,
yet its material initialization involves density.&quot;);
    <font color="blue">elseif </font>initMaterial == InitScalar.Volume<font color="blue"> then</font>
      V = V_IC;
    <font color="blue">elseif </font>initMaterial == InitScalar.VolumeSS<font color="blue"> then</font>
      <font color="red">der</font>(V) = 0;
    <font color="blue">elseif </font>initMaterial == InitScalar.Pressure<font color="blue"> then</font>
      p = p_IC;
    <font color="blue">elseif </font>initMaterial == InitScalar.PressureSS<font color="blue"> then</font>
      <font color="red">der</font>(p) = 0;
    <font color="blue">elseif </font>initMaterial == InitScalar.Temperature<font color="blue"> then</font>
      T = T_IC;
    <font color="blue">elseif </font>initMaterial == InitScalar.TemperatureSS<font color="blue"> then</font>
      <font color="red">der</font>(T) = 0;
    <font color="blue">elseif </font>initMaterial == InitScalar.SpecificEnthalpy<font color="blue"> then</font>
      h = h_IC;
    <font color="blue">elseif </font>initMaterial == InitScalar.SpecificEnthalpySS<font color="blue"> then</font>
      <font color="red">der</font>(h) = 0;
    <font color="blue">elseif </font>initMaterial == InitScalar.PotentialGibbs<font color="blue"> then</font>
      chemical.mu = g_IC;
    <font color="blue">elseif </font>initMaterial == InitScalar.PotentialGibbsSS<font color="blue"> then</font>
      <font color="red">der</font>(chemical.mu) = 0;
      <font color="darkgreen">// Else there&#39;s no initial equation since</font>
      <font color="darkgreen">// initMaterial == InitScalar.None or</font>
      <font color="darkgreen">// consMaterial == Conservation.Steady.</font>
    <font color="blue">end if</font>;
  <font color="blue">end if</font>;

  <font color="darkgreen">// Translational momentum</font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:n_trans<font color="blue"> loop</font>
    <font color="blue">if </font>consTrans[cartTrans[i]] == Conservation.IC<font color="blue"> then</font>
      <font color="darkgreen">// Ensure that a condition is selected since the state is</font>
      <font color="darkgreen">// prescribed.</font>
      <font color="red">assert</font>(initTrans[cartTrans[i]] &lt;&gt; InitTranslational.None, &quot;The state for the &quot;
         + (<font color="blue">if </font>cartTrans[i] == Axis.x<font color="blue"> then </font>&quot;x&quot;<font color="blue"> else </font><font color="blue">if </font>cartTrans[i] == Axis.y<font color="blue">
         then </font>&quot;y&quot;<font color="blue"> else </font>&quot;z&quot;) + &quot;-axis component of translational momentum of &quot; +
        Data.formula + &quot; is prescribed,
yet its condition is not defined.  Choose any condition besides None.&quot;);
    <font color="blue">elseif </font>consTrans[cartTrans[i]] == Conservation.Dynamic<font color="blue"> then</font>
      <font color="darkgreen">// Initialize since there&#39;s a time-varying state.</font>
      <font color="blue">if </font>initTrans[cartTrans[i]] == InitTranslational.Velocity<font color="blue"> then</font>
        phi[i] = phi_IC[cartTrans[i]];
      <font color="blue">elseif </font>initTrans[cartTrans[i]] == InitTranslational.VelocitySS<font color="blue"> then</font>
        <font color="red">der</font>(phi[i]) = 0;
      <font color="blue">elseif </font>initTrans[cartTrans[i]] == InitTranslational.Current<font color="blue"> then</font>
        I[i] = I_IC[cartTrans[i]];
      <font color="blue">elseif </font>initTrans[cartTrans[i]] == InitTranslational.CurrentSS<font color="blue"> then</font>
        <font color="red">der</font>(I[i]) = 0;
        <font color="darkgreen">// Else there&#39;s no initial equation since</font>
        <font color="darkgreen">// initTrans[cartTrans[i]] == InitTranslational.None or</font>
        <font color="darkgreen">// consTrans[cartTrans[i]] == Conservation.Steady.</font>
      <font color="blue">end if</font>;
    <font color="blue">end if</font>;
  <font color="blue">end for</font>;

  <font color="darkgreen">// Energy</font>
  <font color="blue">if </font>consEnergy == Conservation.IC<font color="blue"> then</font>
    <font color="darkgreen">// Ensure that a condition is selected since the state is prescribed.</font>
    <font color="red">assert</font>(initEnergy &lt;&gt; InitScalar.None, &quot;The energy state of &quot; + Data.formula + &quot; is prescribed,
yet its condition is not defined.  Choose any condition besides None.&quot;);
  <font color="blue">elseif </font>consEnergy == Conservation.Dynamic<font color="blue"> then</font>
    <font color="darkgreen">// Initialize since there&#39;s a time-varying state.</font>
    <font color="blue">if </font>initEnergy == InitScalar.Amount<font color="blue"> then</font>
      N = N_IC;
    <font color="blue">elseif </font>initEnergy == InitScalar.AmountSS<font color="blue"> then</font>
      <font color="red">der</font>(N) = 0;
    <font color="blue">elseif </font>initEnergy == InitScalar.Density<font color="blue"> then</font>
      1/v = rho_IC;
      <font color="red">assert</font>(Data.hasThermalExpansion, Data.formula + &quot; has no thermal expansion,
yet its thermal initialization involves density.&quot;);
    <font color="blue">elseif </font>initEnergy == InitScalar.DensitySS<font color="blue"> then</font>
      <font color="red">der</font>(1/v) = 0;
      <font color="red">assert</font>(Data.hasThermalExpansion, Data.formula + &quot; has no thermal expansion,
yet its thermal initialization involves density.&quot;);
    <font color="blue">elseif </font>initEnergy == InitScalar.Volume<font color="blue"> then</font>
      V = V_IC;
    <font color="blue">elseif </font>initEnergy == InitScalar.VolumeSS<font color="blue"> then</font>
      <font color="red">der</font>(V) = 0;
    <font color="blue">elseif </font>initEnergy == InitScalar.Pressure<font color="blue"> then</font>
      p = p_IC;
    <font color="blue">elseif </font>initEnergy == InitScalar.PressureSS<font color="blue"> then</font>
      <font color="red">der</font>(p) = 0;
    <font color="blue">elseif </font>initEnergy == InitScalar.Temperature<font color="blue"> then</font>
      T = T_IC;
    <font color="blue">elseif </font>initEnergy == InitScalar.TemperatureSS<font color="blue"> then</font>
      <font color="red">der</font>(T) = 0;
    <font color="blue">elseif </font>initEnergy == InitScalar.SpecificEnthalpy<font color="blue"> then</font>
      h = h_IC;
    <font color="blue">elseif </font>initEnergy == InitScalar.SpecificEnthalpySS<font color="blue"> then</font>
      <font color="red">der</font>(h) = 0;
    <font color="blue">elseif </font>initEnergy == InitScalar.PotentialGibbs<font color="blue"> then</font>
      chemical.mu = g_IC;
    <font color="blue">elseif </font>initEnergy == InitScalar.PotentialGibbsSS<font color="blue"> then</font>
      <font color="red">der</font>(chemical.mu) = 0;
      <font color="darkgreen">// Else there&#39;s no initial equation since</font>
      <font color="darkgreen">// initEnergy == InitScalar.None or</font>
      <font color="darkgreen">// consEnergy == Conservation.Steady.</font>
    <font color="blue">end if</font>;
  <font color="blue">end if</font>;

<font color="blue">equation </font>
  <font color="darkgreen">// Aliases (only to clarify and simplify other equations)</font>
  T = inert.thermal.T;
  p = inertDalton.p;
  V = inertDalton.V;
  v*N = V;
  M = Data.m*N;
  phi = inert.translational.phi;
  I .* L[cartTrans] = N*phi;
  p_faces = {{<font color="red">Data.p_Tv</font>(faces[i, side].T, 1/faces[i, side].rho) <font color="blue">for </font>side<font color="blue"> in </font>
    Side} <font color="blue">for </font>i<font color="blue"> in </font>1:n_faces};
  Ndot_faces = faces.Ndot + faces.rho .* {{faces[i, Side.n].phi[Orientation.normal],
    -faces[i, Side.p].phi[Orientation.normal]}*A[cartFaces[i]] <font color="blue">for </font>i<font color="blue"> in </font>1:
    n_faces};
  phi_actual_chemical = <font color="red">actualStream</font>(chemical.phi);
  phi_actual_physical = <font color="red">actualStream</font>(physical.phi);

  <font color="darkgreen">// Thermodynamic correlations</font>
  <font color="blue">if </font>invertEOS<font color="blue"> then</font>
    p = <font color="red">Data.p_Tv</font>(T, v);
  <font color="blue">else</font>
    v = <font color="red">Data.v_Tp</font>(T, p);
  <font color="blue">end if</font>;
  h = <font color="red">Data.h</font>(T, p);
  s = <font color="red">Data.s</font>(T, p);
  g0 = <font color="red">Data.g</font>(T, Data.p0);

  <font color="darkgreen">// Diffusive exchange</font>
  chemical.mu = h - chemical.sT <font color="darkgreen">&quot;Reaction (rate equation elsewhere)&quot;</font>;
  <font color="blue">if </font>tauprime &gt;= Modelica.Constants.small<font color="blue"> then</font>
    tauprime*physical.Ndot = N*(<font color="red">exp</font>((physical.mu - g0)/T) - <font color="red">exp</font>((chemical.mu -
      g0)/T)) <font color="darkgreen">&quot;Phase change&quot;</font>;
  <font color="blue">else</font>
    0 = <font color="blue">if </font>N &gt; 0<font color="blue"> or </font>physical.mu &gt; chemical.mu<font color="blue"> then </font>physical.mu - chemical.mu<font color="blue">
       else </font>physical.Ndot;
    <font color="darkgreen">// The first branch avoids nonlinear equations when tauprime=0.</font>
    <font color="darkgreen">// Dymola 7.4 can&#39;t derive it symbolically from the previous equation.</font>
  <font color="blue">end if</font>;
  mu*inertDalton.mPhidot = N*(inertDalton.phi - phi) <font color="darkgreen">&quot;Translational momentum&quot;</font>;
  nu*inertDalton.Qdot = N*(inertDalton.T - T) <font color="darkgreen">&quot;Thermal energy&quot;</font>;

  <font color="darkgreen">// Properties upon outflow due to reaction and phase change</font>
  chemical.phi = phi;
  physical.phi = phi;
  chemical.sT = s*T;
  physical.sT = chemical.sT;

  <font color="darkgreen">// Diffusive transport</font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:n_faces<font color="blue"> loop</font>
    <font color="blue">for </font>side<font color="blue"> in </font>Side<font color="blue"> loop</font>
      <font color="darkgreen">// Material (central difference)</font>
      eta*faces[i, side].Ndot = Lprime[cartFaces[i]]*(faces[i, side].rho - 1/v)*
        2;

      <font color="darkgreen">// Translational momentum</font>
      beta*faces[i, side].mPhidot[Orientation.normal] = Lprime[cartFaces[i]]*(
        faces[i, side].phi[Orientation.normal] - (<font color="blue">if </font>inclTrans[cartFaces[i]]<font color="blue">
         then </font>phi[transCart[cartFaces[i]]]<font color="blue"> else </font>0))*(<font color="blue">if </font>inclTrans[cartFaces[i]]<font color="blue">
         and </font>upstream[cartFaces[i]]<font color="blue"> then </font>1 + <font color="red">exp</font>(-<font color="red">inSign</font>(side)*I[transCart[
        cartFaces[i]]]*beta*Data.m/(2*Lprime[cartFaces[i]]))<font color="blue"> else </font>2) <font color="darkgreen">&quot;Normal&quot;</font>;
      zeta*faces_mPhidot[i, side, Orientation.following - 1] = Nu_Phi[cartFaces[
        i]]*Lprime[cartFaces[i]]*(faces[i, side].phi[Orientation.following] - (<font color="blue">
        if </font>inclTrans[<font color="red">cartWrap</font>(cartFaces[i] + 1)]<font color="blue"> then </font>phi[transCart[<font color="red">cartWrap</font>(
        cartFaces[i] + 1)]]<font color="blue"> else </font>0))*(<font color="blue">if </font>inclTrans[cartFaces[i]]<font color="blue"> and </font>upstream[
        cartFaces[i]]<font color="blue"> then </font>1 + <font color="red">exp</font>(-<font color="red">inSign</font>(side)*I[transCart[cartFaces[i]]]*
        zeta*Data.m/(2*Lprime[cartFaces[i]]))<font color="blue"> else </font>2) <font color="darkgreen">&quot;1st transverse&quot;</font>;
      zeta*faces_mPhidot[i, side, Orientation.preceding - 1] = Nu_Phi[cartFaces[
        i]]*Lprime[cartFaces[i]]*(faces[i, side].phi[Orientation.preceding] - (<font color="blue">
        if </font>inclTrans[<font color="red">cartWrap</font>(cartFaces[i] - 1)]<font color="blue"> then </font>phi[transCart[<font color="red">cartWrap</font>(
        cartFaces[i] - 1)]]<font color="blue"> else </font>0))*(<font color="blue">if </font>inclTrans[cartFaces[i]]<font color="blue"> and </font>upstream[
        cartFaces[i]]<font color="blue"> then </font>1 + <font color="red">exp</font>(-<font color="red">inSign</font>(side)*I[transCart[cartFaces[i]]]*
        zeta*Data.m/(2*Lprime[cartFaces[i]]))<font color="blue"> else </font>2) <font color="darkgreen">&quot;2nd transverse&quot;</font>;

      <font color="darkgreen">// Thermal energy</font>
      theta*faces[i, side].Qdot = Nu_Q*Lprime[cartFaces[i]]*(faces[i, side].T -
        T)*(<font color="blue">if </font>inclTrans[cartFaces[i]]<font color="blue"> and </font>upstream[cartFaces[i]]<font color="blue"> then </font>1 + <font color="red">exp</font>(-<font color="red">
        inSign</font>(side)*I[transCart[cartFaces[i]]]*theta*<font color="red">Data.c_v</font>(T, p)/(2*Lprime[
        cartFaces[i]]))<font color="blue"> else </font>2);
    <font color="blue">end for</font>;

    <font color="darkgreen">// Direct mapping of transverse forces (calculated above)</font>
    <font color="blue">if </font><font color="blue">not </font>inclRot[<font color="red">cartWrap</font>(cartFaces[i] - 1)]<font color="blue"> then</font>
      faces[i, :].mPhidot[Orientation.following] = faces_mPhidot[i, :,
        Orientation.following - 1];
      <font color="darkgreen">// Else the force must be mapped for zero torque (below).</font>
    <font color="blue">end if</font>;
    <font color="blue">if </font><font color="blue">not </font>inclRot[<font color="red">cartWrap</font>(cartFaces[i] + 1)]<font color="blue"> then</font>
      faces[i, :].mPhidot[Orientation.preceding] = faces_mPhidot[i, :,
        Orientation.preceding - 1];
      <font color="darkgreen">// Else the force must be mapped for zero torque (below).</font>
    <font color="blue">end if</font>;
  <font color="blue">end for</font>;

  <font color="darkgreen">// Zero-torque mapping of transverse forces</font>
  <font color="blue">for </font>axis<font color="blue"> in </font>cartRot<font color="blue"> loop</font>
    4*<font color="red">cat</font>(
      1,
      faces[facesCart[<font color="red">cartWrap</font>(axis + 1)], :].mPhidot[Orientation.following],
      faces[facesCart[<font color="red">cartWrap</font>(axis - 1)], :].mPhidot[Orientation.preceding]) =
      {{3,1,L[<font color="red">cartWrap</font>(axis - 1)]/L[<font color="red">cartWrap</font>(axis + 1)],-L[<font color="red">cartWrap</font>(axis - 1)]/
      L[<font color="red">cartWrap</font>(axis + 1)]},{1,3,-L[<font color="red">cartWrap</font>(axis - 1)]/L[<font color="red">cartWrap</font>(axis + 1)],
      L[<font color="red">cartWrap</font>(axis - 1)]/L[<font color="red">cartWrap</font>(axis + 1)]},{L[<font color="red">cartWrap</font>(axis + 1)]/L[<font color="red">
      cartWrap</font>(axis - 1)],-L[<font color="red">cartWrap</font>(axis + 1)]/L[<font color="red">cartWrap</font>(axis - 1)],3,1},{-L[<font color="red">
      cartWrap</font>(axis + 1)]/L[<font color="red">cartWrap</font>(axis - 1)],L[<font color="red">cartWrap</font>(axis + 1)]/L[<font color="red">
      cartWrap</font>(axis - 1)],1,3}}*<font color="red">cat</font>(
      1,
      faces_mPhidot[facesCart[<font color="red">cartWrap</font>(axis + 1)], :, Orientation.following - 1],
      faces_mPhidot[facesCart[<font color="red">cartWrap</font>(axis - 1)], :, Orientation.preceding - 1]);
  <font color="blue">end for</font>;

  <font color="darkgreen">// Material dynamics</font>
  <font color="blue">if </font>consMaterial == Conservation.IC<font color="blue"> then</font>
    <font color="darkgreen">// Apply the IC forever (material not conserved).</font>
    <font color="blue">if </font>initMaterial == InitScalar.Amount<font color="blue"> then</font>
      N = N_IC;
    <font color="blue">elseif </font>initMaterial == InitScalar.AmountSS<font color="blue"> then</font>
      <font color="red">der</font>(N) = 0;
    <font color="blue">elseif </font>initMaterial == InitScalar.Density<font color="blue"> then</font>
      1/v = rho_IC;
    <font color="blue">elseif </font>initMaterial == InitScalar.DensitySS<font color="blue"> then</font>
      <font color="red">der</font>(1/v) = 0;
    <font color="blue">elseif </font>initMaterial == InitScalar.Volume<font color="blue"> then</font>
      V = V_IC;
    <font color="blue">elseif </font>initMaterial == InitScalar.VolumeSS<font color="blue"> then</font>
      <font color="red">der</font>(V) = 0;
    <font color="blue">elseif </font>initMaterial == InitScalar.Pressure<font color="blue"> then</font>
      p = p_IC;
    <font color="blue">elseif </font>initMaterial == InitScalar.PressureSS<font color="blue"> then</font>
      <font color="red">der</font>(p) = 0;
    <font color="blue">elseif </font>initMaterial == InitScalar.Temperature<font color="blue"> then</font>
      T = T_IC;
    <font color="blue">elseif </font>initMaterial == InitScalar.TemperatureSS<font color="blue"> then</font>
      <font color="red">der</font>(T) = 0;
    <font color="blue">elseif </font>initMaterial == InitScalar.SpecificEnthalpy<font color="blue"> then</font>
      h = h_IC;
    <font color="blue">elseif </font>initMaterial == InitScalar.SpecificEnthalpySS<font color="blue"> then</font>
      <font color="red">der</font>(h) = 0;
    <font color="blue">elseif </font>initMaterial == InitScalar.PotentialGibbs<font color="blue"> then</font>
      chemical.mu = g_IC;
    <font color="blue">else</font>
      <font color="darkgreen">// if initMaterial == InitScalar.PotentialGibbsSS then</font>
      <font color="red">der</font>(chemical.mu) = 0;
      <font color="darkgreen">// Note:  initMaterial == InitScalar.None can&#39;t occur due to an</font>
      <font color="darkgreen">// assertion.</font>
    <font color="blue">end if</font>;
  <font color="blue">else</font>
    (<font color="blue">if </font>consMaterial == Conservation.Dynamic<font color="blue"> then </font><font color="red">der</font>(N)/U.s<font color="blue"> else </font>0) = chemical.Ndot
       + physical.Ndot + <font color="red">sum</font>(Ndot_faces) <font color="darkgreen">&quot;Material conservation&quot;</font>;
  <font color="blue">end if</font>;

  <font color="darkgreen">// Translational dynamics</font>
  <font color="blue">for </font>j<font color="blue"> in </font>1:n_trans<font color="blue"> loop</font>
    <font color="blue">if </font>consTrans[cartTrans[j]] == Conservation.IC<font color="blue"> then</font>
      <font color="darkgreen">// Apply the IC forever (translational momentum isn&#39;t conserved along</font>
      <font color="darkgreen">// this axis).</font>
      <font color="blue">if </font>initTrans[cartTrans[j]] == InitTranslational.Velocity<font color="blue"> then</font>
        phi[j] = phi_IC[cartTrans[j]];
      <font color="blue">elseif </font>initTrans[cartTrans[j]] == InitTranslational.VelocitySS<font color="blue"> then</font>
        <font color="red">der</font>(phi[j]) = 0;
      <font color="blue">elseif </font>initTransX == InitTranslational.Current<font color="blue"> then</font>
        I[j] = I_IC[cartTrans[j]];
      <font color="blue">else</font>
        <font color="darkgreen">// if initTrans[cartTrans[j]] == InitTranslational.CurrentSS then</font>
        <font color="red">der</font>(I[j]) = 0;
        <font color="darkgreen">// Note:  initTrans[cartTrans[j]] == InitTranslational.None can&#39;t</font>
        <font color="darkgreen">// occur due to an assertion.</font>
      <font color="blue">end if</font>;
    <font color="blue">else</font>
      M*((<font color="blue">if </font>consTrans[cartTrans[j]] == Conservation.Dynamic<font color="blue"> then </font><font color="red">der</font>(phi[j])/U.s<font color="blue">
         else </font>0) + environment.a[cartTrans[j]]) + N*Data.z*environment.E[
        cartTrans[j]] + (<font color="blue">if </font>inclFaces[cartTrans[j]]<font color="blue"> then </font><font color="red">Delta</font>(p_faces[
        facesCart[cartTrans[j]], :])*A[cartTrans[j]]<font color="blue"> else </font>0) = Data.m*((
        phi_actual_chemical[j] - phi[j])*chemical.Ndot + (phi_actual_physical[j]
         - phi[j])*physical.Ndot) + inert.translational.mPhidot[j] +
        inertDalton.mPhidot[j] + <font color="red">sum</font>((faces[i, :].phi[<font color="red">cartWrap</font>(cartTrans[j] -
        cartFaces[i] + 1)] - {phi[j],phi[j]})*Ndot_faces[i, :]*Data.m + <font color="red">Sigma</font>(
        faces[i, :].mPhidot[<font color="red">cartWrap</font>(cartTrans[j] - cartFaces[i] + 1)]) <font color="blue">for </font>i<font color="blue">
         in </font>1:n_faces) <font color="darkgreen">&quot;Conservation of translational momentum&quot;</font>;
      <font color="darkgreen">// Note:  Dymola 7.4 (Dassl integrator) runs better with this intensive</font>
      <font color="darkgreen">// form of the balance (M*der(phi) = &hellip; rather than der(M*phi) = &hellip;).</font>
    <font color="blue">end if</font>;
  <font color="blue">end for</font>;

  <font color="darkgreen">// Thermal dynamics</font>
  <font color="blue">if </font>consEnergy == Conservation.IC<font color="blue"> then</font>
    <font color="darkgreen">// Apply the IC forever (energy not conserved).</font>
    <font color="blue">if </font>initEnergy == InitScalar.Amount<font color="blue"> then</font>
      N = N_IC;
    <font color="blue">elseif </font>initEnergy == InitScalar.AmountSS<font color="blue"> then</font>
      <font color="red">der</font>(N) = 0;
    <font color="blue">elseif </font>initMaterial == InitScalar.Density<font color="blue"> then</font>
      1/v = rho_IC;
    <font color="blue">elseif </font>initMaterial == InitScalar.DensitySS<font color="blue"> then</font>
      <font color="red">der</font>(1/v) = 0;
    <font color="blue">elseif </font>initEnergy == InitScalar.Volume<font color="blue"> then</font>
      V = V_IC;
    <font color="blue">elseif </font>initEnergy == InitScalar.VolumeSS<font color="blue"> then</font>
      <font color="red">der</font>(V) = 0;
    <font color="blue">elseif </font>initEnergy == InitScalar.Pressure<font color="blue"> then</font>
      p = p_IC;
    <font color="blue">elseif </font>initEnergy == InitScalar.PressureSS<font color="blue"> then</font>
      <font color="red">der</font>(p) = 0;
    <font color="blue">elseif </font>initEnergy == InitScalar.Temperature<font color="blue"> then</font>
      T = T_IC;
    <font color="blue">elseif </font>initEnergy == InitScalar.TemperatureSS<font color="blue"> then</font>
      <font color="red">der</font>(T) = 0;
    <font color="blue">elseif </font>initEnergy == InitScalar.SpecificEnthalpy<font color="blue"> then</font>
      h = h_IC;
    <font color="blue">elseif </font>initEnergy == InitScalar.SpecificEnthalpySS<font color="blue"> then</font>
      <font color="red">der</font>(h) = 0;
    <font color="blue">elseif </font>initEnergy == InitScalar.PotentialGibbs<font color="blue"> then</font>
      chemical.mu = g_IC;
    <font color="blue">else</font>
      <font color="darkgreen">// if initEnergy == InitScalar.PotentialGibbsSS then</font>
      <font color="red">der</font>(chemical.mu) = 0;
      <font color="darkgreen">// Note:  initEnergy == InitScalar.None can&#39;t occur due to an</font>
      <font color="darkgreen">// assertion.</font>
    <font color="blue">end if</font>;
  <font color="blue">else</font>
    (<font color="blue">if </font>consEnergy == Conservation.Dynamic<font color="blue"> then </font>(N*T*<font color="red">der</font>(s) + M*phi*<font color="red">der</font>(phi))/U.s<font color="blue">
       else </font>0) = (chemical.mu + <font color="red">actualStream</font>(chemical.sT) - h + (<font color="red">actualStream</font>(
      chemical.phi)*<font color="red">actualStream</font>(chemical.phi) - phi*phi)*Data.m/2)*chemical.Ndot
       + (physical.mu + <font color="red">actualStream</font>(physical.sT) - h + (<font color="red">actualStream</font>(physical.phi)
      *<font color="red">actualStream</font>(physical.phi) - phi*phi)*Data.m/2)*physical.Ndot + inert.translational.phi
      *inert.translational.mPhidot + inert.thermal.Qdot + inertDalton.phi*
      inertDalton.mPhidot + inertDalton.Qdot + <font color="red">sum</font>((<font color="red">Data.h</font>(faces[i, :].T,
      p_faces[i, :]) - {h,h})*Ndot_faces[i, :] + <font color="red">sum</font>((faces[i, :].phi[<font color="red">cartWrap</font>(
      cartTrans[j] - cartFaces[i] + 1)] .^ 2 - <font color="red">fill</font>(phi[j]^2, 2))*Ndot_faces[i,
      :]*Data.m/2 + faces[i, :].phi[<font color="red">cartWrap</font>(cartTrans[j] - cartFaces[i] + 1)]*
      faces[i, :].mPhidot[<font color="red">cartWrap</font>(cartTrans[j] - cartFaces[i] + 1)] <font color="blue">for </font>j<font color="blue"> in </font>1:
      n_trans) <font color="blue">for </font>i<font color="blue"> in </font>1:n_faces) + <font color="red">sum</font>(faces.Qdot) <font color="darkgreen">&quot;Conservation of energy&quot;</font>;
  <font color="blue">end if</font>;
<font color="blue">end </font>Species;
</pre>
      </div>
    </div>
  </div>
</div>
<div class="footer">
  &copy; Copyright 2012&ndash;2013, Kevin Davies, Georgia Tech Research Corporation. Last updated Tue Jul  2 09:28:59 2013.
</div>
</body>
</html>
